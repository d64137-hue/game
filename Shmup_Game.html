<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ÂºæÂπï„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞„Ç≤„Éº„É† (Wave„Çµ„Éê„Ç§„Éê„É´/„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„ÉâÁâà)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            background: #2a2a2a; 
            color: white; 
            text-align: center; 
            font-family: sans-serif; 
            margin: 0; 
            padding-top: 20px; 
            padding-bottom: 50px; 
            overflow-y: auto;
        }
        h1 {
            color: #76FF03;
            margin-bottom: 20px;
        }
        #NewGameArea {
            max-width: 600px; /* Canvas„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥ */
            margin: 0 auto;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #1e1e1e;
        }
        #NewGameCanvas {
            background: #00001a;
            border: 2px solid #76FF03;
            display: block;
            margin: 20px auto;
            cursor: pointer; 
            touch-action: none; 
        }
        #game-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #76FF03;
        }
        /* „Ç∑„Éß„ÉÉ„ÉóÁîªÈù¢Áî®„Çπ„Çø„Ç§„É´ */
        #shop-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .shop-panel {
            background: #333;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            width: 90%;
            max-width: 500px;
            text-align: left;
        }
        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px dashed #555;
        }
        .shop-item:last-child {
            border-bottom: none;
        }
        .shop-item button {
            padding: 8px 15px;
            background-color: #76FF03;
            color: #1e1e1e;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.1s;
        }
        .shop-item button:disabled {
            background-color: #555;
            color: #aaa;
            cursor: not-allowed;
        }
        .shop-item .details {
            font-size: 0.9em;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div id="NewGameArea">
        <h1>üåå Wave„Çµ„Éê„Ç§„Éê„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞</h1>
        
        <div id="game-info">
            Wave: <span id="wave-display">1</span> | GOLD: <span id="gold-display">0</span> | Lives: <span id="lives-display">3</span>
        </div>

        <div style="position: relative;">
            <canvas id="NewGameCanvas" width="500" height="650"></canvas>
            
            <div id="overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;">
                <div id="start-screen" style="background: rgba(0, 0, 0, 0.9); padding: 40px; border-radius: 10px; text-align: center;">
                    <h2>Wave„Çµ„Éê„Ç§„Éê„É´ÈñãÂßãÔºÅ</h2>
                    <p>WASD/Áü¢Âç∞„Ç≠„Éº„ÅßÁßªÂãï„ÄÅX/„Çπ„Éö„Éº„Çπ„ÅßÊîªÊíÉ„ÄÇ<br>J, K, L„Åß„Çπ„Ç≠„É´Áô∫ÂãïÔºÅ</p>
                    <button onclick="startGame()" style="padding: 15px 30px; font-size: 1.5em; background: #76FF03; color: black; border: none; border-radius: 5px; margin-top: 20px;">„Çπ„Çø„Éº„Éà WAVE 1</button>
                </div>

                <div id="shop-container" style="display: none;">
                    </div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('NewGameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // --- „Ç≤„Éº„É†Áä∂ÊÖãÂ§âÊï∞ ---
        let gameStatus = 'init'; // 'init', 'playing', 'shop', 'gameover'
        let currentWave = 0;
        let score = 0;
        let keys = {};
        let player;
        let enemy;
        let playerBullets = [];
        let enemyBullets = [];
        let items = []; // GOLD„Éâ„É≠„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†Áî®

        let gameFrame = 0;
        let isDragging = false; 
        let dragOffsetX = 0;
        let dragOffsetY = 0; 
        
        const TRAIL_LENGTH = 10;
        const trail = []; 

        // --- „Ç≤„Éº„É†ÂÆöÊï∞„Å®„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ„Ç∑„Çπ„ÉÜ„É† ---
        const BASE_FIRE_RATE = 8; // 8„Éï„É¨„Éº„É†„Å´1Áô∫
        const BASE_MOVE_SPEED = 4.5;
        const BASE_BULLET_DMG = 10;
        const BASE_MAX_LIVES = 3;

        let stats = {
            gold: 0,
            lives: BASE_MAX_LIVES,
            maxLives: BASE_MAX_LIVES,
            bulletDmg: BASE_BULLET_DMG,
            fireRate: BASE_FIRE_RATE,
            moveSpeed: BASE_MOVE_SPEED,
        };

        let skillData = {
            HEAL: { level: 0, cd: 90, currentCd: 0, cost: 200, key: 'j', maxLevel: 5 },
            FULL_BURST: { level: 0, cd: 45, currentCd: 0, cost: 150, key: 'k', maxLevel: 5 },
            BOMB: { level: 0, cd: 60, currentCd: 0, cost: 300, key: 'l', maxLevel: 5 },
            SLOW_FIELD: { level: 0, cd: 40, currentCd: 0, cost: 250, key: 'i', maxLevel: 3 },
            MAGNET: { level: 0, cd: 75, currentCd: 0, cost: 200, key: 'o', maxLevel: 3 },
            TRACE_LASER: { level: 0, cd: 50, currentCd: 0, cost: 350, key: 'p', maxLevel: 5 }
        };
        // „Çπ„Ç≠„É´„ÇíJ, K, L„Å´Ââ≤„ÇäÂΩì„Å¶„Çã („Åì„ÅÆÈÖçÂàó„ÅßÁÆ°ÁêÜ)
        let equippedSkills = ['HEAL', 'FULL_BURST', 'BOMB']; 
        
        // „Çπ„Ç≠„É´Áô∫Âãï‰∏≠„ÅÆÁä∂ÊÖã
        let skillEffects = {
            fullBurst: 0, 
            slowField: 0,
            magnet: 0,
            traceLaser: { active: false, x: 0, y: 0, duration: 0 }
        };

        const SHOP_ITEMS = {
            BULLET_DMG: { name: "ÁÅ´Âäõ„Ç¢„ÉÉ„Éó", type: "stat", desc: "Âºæ„ÅÆ„ÉÄ„É°„Éº„Ç∏Â¢óÂä†", baseCost: 100, stat: 'bulletDmg', step: 10 },
            FIRE_RATE: { name: "ÈÄ£Â∞ÑÈÄüÂ∫¶„Ç¢„ÉÉ„Éó", type: "stat", desc: "ÈÄ£Â∞ÑÈÄüÂ∫¶Âêë‰∏ä", baseCost: 150, stat: 'fireRate', step: -0.5, min: 2 },
            MOVE_SPEED: { name: "ÁßªÂãïÈÄüÂ∫¶„Ç¢„ÉÉ„Éó", type: "stat", desc: "ÁßªÂãïÈÄüÂ∫¶Âêë‰∏ä", baseCost: 100, stat: 'moveSpeed', step: 0.5 },
            MAX_LIFE: { name: "ÊúÄÂ§ß„É©„Ç§„Éï„Ç¢„ÉÉ„Éó", type: "stat", desc: "ÊúÄÂ§ß„É©„Ç§„Éï+1", baseCost: 200, stat: 'maxLives', step: 1 },
            HEAL_CURRENT: { name: "„É©„Ç§„ÉïÂõûÂæ©", type: "heal", desc: "ÁèæÂú®„ÅÆ„É©„Ç§„Éï„Çí1ÂõûÂæ© (Max„Åæ„Åß)", baseCost: 100, stat: 'lives', step: 1 }
        };

        // --- „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇØ„É©„Çπ ---

        // „Éó„É¨„Ç§„É§„Éº 
        class Player {
            constructor() {
                this.width = 20; 
                this.height = 20;
                this.x = WIDTH / 2 - this.width / 2;
                this.y = HEIGHT - this.height - 10;
                this.color = 'cyan';
                this.hitRadius = 3; 
                this.currentLife = stats.lives;
            }

            update() {
                if (isDragging) return; 

                const isSlow = keys['Shift'] || keys['z']; 
                let currentSpeed = stats.moveSpeed;
                if (isSlow) currentSpeed = stats.moveSpeed * 0.8 / 4.5 * 0.8; // BASE_MOVE_SPEEDÊôÇ„ÅÆslowSpeed (0.8)„ÇíÂü∫Ê∫ñ„Å´Ë™øÊï¥

                if (keys['ArrowLeft'] || keys['a']) this.x -= currentSpeed;
                if (keys['ArrowRight'] || keys['d']) this.x += currentSpeed;
                if (keys['ArrowUp'] || keys['w']) this.y -= currentSpeed; 
                if (keys['ArrowDown'] || keys['s']) this.y += currentSpeed; 

                // ÁîªÈù¢Â§ñ„Å´Âá∫„Å™„ÅÑ„Çà„ÅÜ„Å´Âà∂Èôê
                this.x = Math.max(0, Math.min(this.x, WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, HEIGHT - this.height));
                
                // ‰ΩéÈÄüÁßªÂãïÊôÇ„ÅÆ„Éà„É¨„Ç§„É´„ÇíÊõ¥Êñ∞
                if (isSlow) {
                    trail.push({ x: this.getCenter().x, y: this.getCenter().y });
                    if (trail.length > TRAIL_LENGTH) {
                        trail.shift();
                    }
                } else {
                    trail.length = 0;
                }
            }
            
            // „ÉÄ„É°„Éº„Ç∏Âá¶ÁêÜ
            takeDamage() {
                this.currentLife--;
                stats.lives = this.currentLife;
                if (this.currentLife <= 0) {
                    gameOver();
                } else {
                    // ‰∏ÄÊôÇÁÑ°ÊïµÂá¶ÁêÜ„Å™„Å©
                }
            }

            draw() {
                const isSlow = keys['Shift'] || keys['z'];
                const center = this.getCenter();

                // 1. ‰ΩéÈÄüÁßªÂãï„Éà„É¨„Ç§„É´
                if (isSlow && trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(trail[0].x, trail[0].y);
                    for (let i = 1; i < trail.length; i++) {
                        ctx.strokeStyle = `rgba(118, 255, 3, ${i / TRAIL_LENGTH * 0.5})`; 
                        ctx.lineWidth = 1;
                        ctx.lineTo(trail[i].x, trail[i].y);
                        ctx.stroke();
                    }
                }
                
                // 2. „Éó„É¨„Ç§„É§„ÉºÊú¨‰ΩìÔºà‰∏âËßíÂΩ¢Ôºâ
                ctx.fillStyle = isSlow ? '#B2FF59' : this.color; 
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.closePath();
                ctx.fill();

                if (isSlow) {
                    ctx.strokeStyle = '#76FF03';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // 3. ÂΩì„Åü„ÇäÂà§ÂÆöÔºàÈªÑËâ≤„ÅÑÁÇπÔºâ
                ctx.fillStyle = isSlow ? 'yellow' : 'red';
                ctx.beginPath();
                ctx.arc(center.x, center.y, this.hitRadius + 1, 0, Math.PI * 2);
                ctx.fill();
            }

            getCenter() {
                return { x: this.x + this.width / 2, y: this.y + this.height / 2, radius: this.hitRadius };
            }
        }

        // Ëá™Ê©üÂºæ
        class PlayerBullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.speed = 10;
                this.damage = stats.bulletDmg;
                this.color = 'yellow';
            }

            update() {
                this.y -= this.speed;
                return this.y < 0; 
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Êïµ
        class Enemy {
            constructor(initialHP) {
                this.width = 40;
                this.height = 40;
                this.x = WIDTH / 2 - this.width / 2;
                this.y = 50; 
                this.color = 'red';
                this.maxHealth = initialHP;
                this.health = initialHP;
                this.fireTimer = 0;
                this.firePattern = 0; 
            }

            update() {
                // Êïµ„ÅÆÁßªÂãï (Wave„ÅåÈÄ≤„ÇÄ„Å®Â∞ë„ÅóÂãï„Åè„Çà„ÅÜ„Å´)
                this.x = WIDTH / 2 + Math.sin(gameFrame * 0.01) * 50 * (currentWave < 5 ? 0 : 1);
                this.x = Math.max(0, Math.min(this.x, WIDTH - this.width));

                this.fireTimer++;
                
                // ÂºæÂπï„Éë„Çø„Éº„É≥Âàá„ÇäÊõø„Åà (‰æã: 150„Éï„É¨„Éº„É†„Åî„Å®)
                if (this.fireTimer > 150 + Math.random() * 50) {
                    this.fireTimer = 0;
                    // Wave„Å´Âøú„Åò„Å¶Êñ∞„Åó„ÅÑ„Éë„Çø„Éº„É≥„ÇíÊ±∫ÂÆö
                    this.firePattern = Math.floor(Math.random() * (currentWave < 3 ? 3 : currentWave < 8 ? 5 : 7)); 
                    this.shoot();
                }

                return this.health <= 0; 
            }

            shoot() {
                let center = this.getCenter();
                let speed = 2 + (currentWave / 10);
                let num, angleStep, startAngle;

                switch (this.firePattern) {
                    case 0: // Âü∫Êú¨„ÅÆ5ÊñπÂêëÊã°Êï£Âºæ
                        num = 5;
                        angleStep = Math.PI * 0.25; 
                        startAngle = Math.PI / 2 - angleStep * (num - 1) / 2;
                        for (let i = 0; i < num; i++) {
                            let angle = startAngle + i * angleStep;
                            let dx = Math.cos(angle) * speed;
                            let dy = Math.sin(angle) * speed;
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'red', dx, 5));
                        }
                        break;
                    case 1: // ÊôÇË®àÂõû„ÇäËû∫ÊóãÂºæ
                        num = 8;
                        angleStep = Math.PI * 2 / num;
                        for (let i = 0; i < num; i++) {
                            let angle = i * angleStep + gameFrame * 0.05;
                            let dx = Math.cos(angle) * speed * 0.8;
                            let dy = Math.sin(angle) * speed * 0.8;
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'purple', dx, 3));
                        }
                        break;
                    case 2: // 10ÁßíÈñìËøΩÂ∞æÂºæ („Éó„É¨„Ç§„É§„Éº„Çø„Éº„Ç≤„ÉÉ„Éà)
                        if (currentWave >= 2) {
                             // „Éó„É¨„Ç§„É§„Éº„Å∏„ÅÆËßíÂ∫¶„ÇíË®àÁÆó
                            let angle = Math.atan2(player.getCenter().y - center.y, player.getCenter().x - center.x);
                            let dx = Math.cos(angle) * speed * 1.5;
                            let dy = Math.sin(angle) * speed * 1.5;
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'lime', dx, 6, 600)); // 600„Éï„É¨„Éº„É†ËøΩÂ∞æ
                        }
                        break;
                    case 3: // ÊîæÂ∞ÑÁä∂„Ç¶„Çß„Éº„ÉñÂºæ
                        num = 12 + currentWave;
                        for (let i = 0; i < num; i++) {
                            let angle = (i * (360 / num) + gameFrame * 0.5) * (Math.PI / 180);
                            let dx = Math.cos(angle) * speed * 0.7;
                            let dy = Math.sin(angle) * speed * 0.7;
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'yellow', dx, 4));
                        }
                        break;
                    case 4: // „É©„É≥„ÉÄ„É†„Å™ÊñπÂêë„Å∏„ÅÆÈ´òÈÄüÂºæ
                        num = 6;
                        for (let i = 0; i < num; i++) {
                            let angle = Math.random() * Math.PI * 2;
                            let s = speed * (1.5 + Math.random() * 0.5);
                            let dx = Math.cos(angle) * s;
                            let dy = Math.sin(angle) * s;
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'orange', dx, 3));
                        }
                        break;
                    case 5: // („Éú„ÇπÂºæÂπï) ÊâáÁä∂„ÅÆËá™ÂºæÁô∫Â∞ÑÂºæ (Êú™ÂÆüË£Ö: ÂçòÁ¥î„Å™Â∫ÉÁØÑÂõ≤Âºæ„Åß‰ª£Áî®)
                    case 6: // („Éú„ÇπÂºæÂπï) Ë§áÊï∞ÊñπÂêë„Åã„Çâ„ÅÆ„É¨„Éº„Ç∂„Éº
                        if (currentWave >= 5) {
                            num = 20;
                            let angleOffset = (gameFrame * 0.05);
                            for (let i = 0; i < num; i++) {
                                let angle = (i * (360 / num) + angleOffset) * (Math.PI / 180);
                                let s = speed * 0.5;
                                let dx = Math.cos(angle) * s;
                                let dy = Math.sin(angle) * s;
                                enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'red', dx, 3));
                                enemyBullets.push(new EnemyBullet(center.x, center.y, -dy, -dy > 0 ? 'blue' : 'blue', dx, 3));
                            }
                        }
                        break;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // HP„Ç≤„Éº„Ç∏„ÅÆÊèèÁîª
                this.drawHealthBar();
            }
            
            drawHealthBar() {
                const barWidth = WIDTH - 40;
                const barHeight = 10;
                const barX = 20;
                const barY = 15;
                const hpRatio = this.health / this.maxHealth;

                // ËÉåÊôØ
                ctx.fillStyle = '#444';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // HP„Éê„Éº
                ctx.fillStyle = '#FF4136'; // Ëµ§
                ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
                
                // Êû†
                ctx.strokeStyle = 'white';
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                ctx.fillStyle = 'white';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`BOSS HP: ${Math.max(0, this.health)} / ${this.maxHealth}`, WIDTH / 2, barY + barHeight + 10);
                
            }

            getCenter() {
                return { x: this.x + this.width / 2, y: this.y + this.height / 2, radius: this.width / 2 };
            }
        }

        // ÊïµÂºæ
        class EnemyBullet {
            constructor(x, y, dy, color = 'red', dx = 0, radius = 5, followDuration = 0) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.baseDx = dx;
                this.baseDy = dy;
                this.color = color;
                this.followDuration = followDuration; // ËøΩÂ∞æ„Éï„É¨„Éº„É†Êï∞
                this.frames = 0;
            }

            update() {
                this.frames++;
                
                let dx = this.baseDx;
                let dy = this.baseDy;

                // „Çπ„É≠„Éº„Éï„Ç£„Éº„É´„ÉâÂäπÊûú
                if (skillEffects.slowField > 0) {
                    dx *= 0.5;
                    dy *= 0.5;
                }

                // ËøΩÂ∞æÂºæÂá¶ÁêÜ
                if (this.frames < this.followDuration) {
                    let target = player.getCenter();
                    let angle = Math.atan2(target.y - this.y, target.x - this.x);
                    let speed = Math.sqrt(this.baseDx * this.baseDx + this.baseDy * this.baseDy);
                    
                    dx = Math.cos(angle) * speed;
                    dy = Math.sin(angle) * speed;
                }

                this.y += dy;
                this.x += dx; 

                return this.y > HEIGHT || this.y < 0 || this.x < 0 || this.x > WIDTH;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // „Ç¢„Ç§„ÉÜ„É† (GOLD)
        class Item {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value;
                this.radius = 5;
                this.color = 'gold';
            }
            
            update() {
                this.y += 1; // Â∏∏„Å´‰∏ã„Å´ËêΩ„Å°„Çã
                
                // „Éû„Ç∞„Éç„ÉÉ„ÉàÂäπÊûú
                if (skillEffects.magnet > 0) {
                    let playerCenter = player.getCenter();
                    let dist = Math.sqrt(Math.pow(playerCenter.x - this.x, 2) + Math.pow(playerCenter.y - this.y, 2));
                    
                    if (dist < 200) { // Á£ÅÂäõÁØÑÂõ≤
                        let angle = Math.atan2(playerCenter.y - this.y, playerCenter.x - this.x);
                        this.x += Math.cos(angle) * 5;
                        this.y += Math.sin(angle) * 5;
                    }
                }

                return this.y > HEIGHT; // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÊ∂àÊªÖ
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'darkorange';
                ctx.stroke();
            }
        }


        // --- „Ç≤„Éº„É†ÁÆ°ÁêÜÈñ¢Êï∞ ---

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('shop-container').style.display = 'none';
            gameStatus = 'playing';
            initGame(1);
        }

        function initGame(wave) {
            currentWave = wave;
            
            // Êïµ„ÅÆÂàùÊúüÂåñ (HP„ÅØWave„Åî„Å®„Å´ÊåáÊï∞Èñ¢Êï∞ÁöÑ„Å´Â¢óÂä†)
            const baseHP = 100;
            const hpMultiplier = 1.5;
            let initialHP = Math.floor(baseHP * Math.pow(hpMultiplier, currentWave - 1));
            if (currentWave % 5 === 0) { // „Éú„ÇπWave
                initialHP *= 2; 
            }
            
            enemy = new Enemy(initialHP);
            player = new Player();
            player.currentLife = stats.lives; 
            
            playerBullets = [];
            enemyBullets = [];
            items = [];
            gameFrame = 0;
            
            updateDisplay();
            if (gameStatus === 'playing') {
                gameLoop();
            }
        }
        
        function startNextWave() {
            // Wave„ÇØ„É™„Ç¢„Éú„Éº„Éä„Çπ
            let bonusGold = 200 + currentWave * 50;
            stats.gold += bonusGold;
            
            // „Ç∑„Éß„ÉÉ„Éó„Å∏ÁßªË°å
            gameStatus = 'shop';
            showShop();
        }

        function checkCollisions() {
            // 1. Ëá™Ê©üÂºæ vs Êïµ
            playerBullets = playerBullets.filter(bullet => {
                const dist = Math.sqrt(Math.pow(bullet.x - enemy.getCenter().x, 2) + Math.pow(bullet.y - enemy.getCenter().y, 2));
                if (dist < bullet.radius + enemy.width / 2) {
                    enemy.health -= bullet.damage; 
                    stats.score += 5; 
                    
                    if (enemy.health <= 0) {
                        stats.score += 500;
                        // ÊïµÊíÉÁ†¥
                        startNextWave();
                    }
                    return false; // Âºæ„ÅØÊ∂à„Åà„Çã
                }
                return !bullet.update();
            });

            // 2. ÊïµÂºæ vs „Éó„É¨„Ç§„É§„Éº
            enemyBullets = enemyBullets.filter(bullet => {
                const playerCenter = player.getCenter();
                const dist = Math.sqrt(Math.pow(bullet.x - playerCenter.x, 2) + Math.pow(bullet.y - playerCenter.y, 2));
                
                if (dist < bullet.radius + playerCenter.radius) {
                    player.takeDamage();
                    updateDisplay();
                    return false; // Âºæ„ÅØÊ∂à„Åà„Çã
                }
                return !bullet.update(); 
            });
            
            // 3. „Éó„É¨„Ç§„É§„Éº vs „Ç¢„Ç§„ÉÜ„É†
            items = items.filter(item => {
                const playerCenter = player.getCenter();
                const dist = Math.sqrt(Math.pow(item.x - playerCenter.x, 2) + Math.pow(item.y - playerCenter.y, 2));
                
                if (dist < item.radius + playerCenter.radius + 10) { // ÂèñÂæóÂà§ÂÆö„ÇíÂ∞ë„ÅóÂ§ß„Åç„Åè
                    stats.gold += item.value;
                    updateDisplay();
                    return false; 
                }
                return !item.update();
            });
        }
        
        // Âºæ„ÅÆÁô∫Â∞ÑÂà∂Âæ°
        function playerShoot() {
            const currentFireRate = stats.fireRate;
            let actualFireRate = currentFireRate;
            
            // „Éï„É´„Éê„Éº„Çπ„Éà„Çπ„Ç≠„É´ÂäπÊûú
            if (skillEffects.fullBurst > 0) {
                actualFireRate = Math.max(2, currentFireRate / (1 + skillData.FULL_BURST.level * 0.5)); 
            }

            if (keys[' '] || keys['x']) {
                if (gameFrame % Math.floor(actualFireRate) === 0) {
                    playerBullets.push(new PlayerBullet(player.x + player.width / 2, player.y));
                }
            }
        }
        
        // „Çπ„Ç≠„É´Áô∫ÂãïÂá¶ÁêÜ
        function activateSkill(skillId) {
            const skill = skillData[skillId];
            if (skill.currentCd > 0) return;
            
            skill.currentCd = skill.cd * (1 - skill.level * 0.05); // „É¨„Éô„É´„Ç¢„ÉÉ„Éó„Åß„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Áü≠Á∏Æ
            
            switch(skillId) {
                case 'HEAL':
                    player.currentLife = Math.min(stats.maxLives, player.currentLife + 1 + Math.floor(skill.level / 2));
                    stats.lives = player.currentLife;
                    updateDisplay();
                    break;
                case 'FULL_BURST':
                    skillEffects.fullBurst = 60 + skill.level * 30; // 1Áßí + „É¨„Éô„É´*0.5Áßí
                    break;
                case 'BOMB':
                    // ÂºæÊ∂àÂéª
                    enemyBullets = [];
                    // Êïµ„Å´„ÉÄ„É°„Éº„Ç∏
                    enemy.health -= 500 + skill.level * 200;
                    if (enemy.health <= 0) startNextWave();
                    break;
                case 'SLOW_FIELD':
                    skillEffects.slowField = 180 + skill.level * 60; // 3Áßí + „É¨„Éô„É´*1Áßí
                    break;
                case 'MAGNET':
                    skillEffects.magnet = 600 + skill.level * 120; // 10Áßí + „É¨„Éô„É´*2Áßí
                    break;
                case 'TRACE_LASER':
                    skillEffects.traceLaser.active = true;
                    skillEffects.traceLaser.duration = 60; // 1ÁßíÊåÅÁ∂ö
                    skillEffects.traceLaser.x = player.getCenter().x;
                    skillEffects.traceLaser.y = player.getCenter().y;
                    break;
            }
        }
        
        // „Çπ„Ç≠„É´„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Êõ¥Êñ∞
        function updateSkills() {
            Object.values(skillData).forEach(skill => {
                if (skill.currentCd > 0) {
                    skill.currentCd--;
                }
            });
            
            Object.keys(skillEffects).forEach(key => {
                if (typeof skillEffects[key] === 'number' && skillEffects[key] > 0) {
                    skillEffects[key]--;
                }
                // „Éà„É¨„Éº„Çπ„É¨„Éº„Ç∂„Éº„ÅØÂÄãÂà•„ÅÆÊõ¥Êñ∞
                if (key === 'traceLaser' && skillEffects.traceLaser.active) {
                    skillEffects.traceLaser.duration--;
                    // Êïµ„Å´„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„É≠„Ç∏„ÉÉ„ÇØ
                    if (gameFrame % 5 === 0) {
                         enemy.health -= 50 + skillData.TRACE_LASER.level * 20; 
                         if (enemy.health <= 0) startNextWave();
                    }
                    if (skillEffects.traceLaser.duration <= 0) {
                        skillEffects.traceLaser.active = false;
                    }
                }
            });
        }
        
        function drawHUD() {
            // „Éó„É¨„Ç§„É§„ÉºHP„Ç≤„Éº„Ç∏
            const pBarWidth = 150;
            const pBarHeight = 15;
            const pBarX = WIDTH - pBarWidth - 10;
            const pBarY = HEIGHT - pBarHeight - 10;
            const pRatio = player.currentLife / stats.maxLives;

            ctx.fillStyle = '#444';
            ctx.fillRect(pBarX, pBarY, pBarWidth, pBarHeight);
            ctx.fillStyle = '#1E90FF'; // Èùí
            ctx.fillRect(pBarX, pBarY, pBarWidth * pRatio, pBarHeight);
            ctx.strokeStyle = 'white';
            ctx.strokeRect(pBarX, pBarY, pBarWidth, pBarHeight);
            
            ctx.fillStyle = 'white';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText(`LIFE: ${player.currentLife}/${stats.maxLives}`, pBarX + pBarWidth, pBarY - 5);
            
            // „Çπ„Ç≠„É´„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥„Ç≤„Éº„Ç∏
            equippedSkills.forEach((skillId, index) => {
                const skill = skillData[skillId];
                const cdRatio = skill.currentCd / (skill.cd * (1 - skill.level * 0.05));
                const cdBarWidth = 80;
                const cdBarHeight = 10;
                const cdBarX = 10;
                const cdBarY = HEIGHT - 50 - (index * 20);
                
                ctx.fillStyle = '#444';
                ctx.fillRect(cdBarX, cdBarY, cdBarWidth, cdBarHeight);
                
                if (skill.currentCd > 0) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(cdBarX, cdBarY, cdBarWidth * cdRatio, cdBarHeight);
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${skill.key.toUpperCase()} - CD: ${(skill.currentCd / 60).toFixed(1)}s`, cdBarX + cdBarWidth + 5, cdBarY + 9);
                } else {
                    ctx.fillStyle = '#76FF03';
                    ctx.fillRect(cdBarX, cdBarY, cdBarWidth, cdBarHeight);
                    ctx.fillStyle = 'black';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${skill.key.toUpperCase()} - READY`, cdBarX + 5, cdBarY + 9);
                }
                
                ctx.strokeStyle = 'white';
                ctx.strokeRect(cdBarX, cdBarY, cdBarWidth, cdBarHeight);
            });
        }
        
        function drawTraceLaser() {
             if (!skillEffects.traceLaser.active) return;
             
             const duration = skillEffects.traceLaser.duration;
             const center = enemy.getCenter();
             
             ctx.save();
             ctx.beginPath();
             
             const alpha = duration > 30 ? 1 : duration / 30; // ÁµÇ„Çè„Çä„Å´Ëøë„Å•„Åè„Å®ËñÑ„Åè„Å™„Çã
             ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
             ctx.lineWidth = 4 + skillData.TRACE_LASER.level * 2;
             
             // „É¨„Éº„Ç∂„Éº„Çí„Éó„É¨„Ç§„É§„Éº„Åã„ÇâÊïµ„ÅÆ‰∏≠ÂøÉ„Å´Âêë„Åã„Å£„Å¶ÊèèÁîª
             ctx.moveTo(player.getCenter().x, player.getCenter().y);
             ctx.lineTo(center.x, center.y);
             ctx.stroke();
             
             ctx.restore();
        }


        function gameOver() {
            gameStatus = 'gameover';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = 'white';
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', WIDTH / 2, HEIGHT / 2 - 30);
            ctx.font = '24px sans-serif';
            ctx.fillText(`Reached Wave: ${currentWave}`, WIDTH / 2, HEIGHT / 2 + 20);
            ctx.fillText(`Final Score: ${stats.score}`, WIDTH / 2, HEIGHT / 2 + 50);
            ctx.fillText('Press R to Restart (Wave 1)', WIDTH / 2, HEIGHT / 2 + 100);
        }

        function updateDisplay() {
            document.getElementById('wave-display').textContent = currentWave;
            document.getElementById('gold-display').textContent = stats.gold;
            document.getElementById('lives-display').textContent = `${stats.lives} / ${stats.maxLives}`;
        }
        
        // --- „Ç∑„Éß„ÉÉ„ÉóÁîªÈù¢„ÅÆË°®Á§∫„Å®Âá¶ÁêÜ ---
        
        function showShop() {
            const shopContainer = document.getElementById('shop-container');
            shopContainer.style.display = 'flex';
            
            let html = `<h2>Wave ${currentWave} CLEAR!</h2>`;
            html += `<p style="font-size: 1.5em; color: gold;">Áç≤Âæó GOLD: ${200 + currentWave * 50}</p>`;
            html += `<p style="font-size: 1.2em;">ÊâÄÊåÅ GOLD: <span id="shop-gold-display">${stats.gold}</span></p><hr>`;
            
            // 1. Âü∫Êú¨„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ
            html += `<div class="shop-panel"><h3>üí™ Âü∫Êú¨ËÉΩÂäõ„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ</h3>`;
            Object.keys(SHOP_ITEMS).forEach(key => {
                const item = SHOP_ITEMS[key];
                const currentVal = stats[item.stat] !== undefined ? stats[item.stat] : 'N/A';
                
                // „Ç≥„Çπ„ÉàË®àÁÆó („É¨„Éô„É´„Åå„Å™„ÅÑ„ÅÆ„Åß„ÄÅÁèæÂú®„ÅÆÂÄ§„Å´Âøú„Åò„Å¶„Ç≥„Çπ„Éà„ÇíÊ±∫ÂÆö)
                let currentLevel = 0;
                if (item.stat === 'bulletDmg') currentLevel = (currentVal - BASE_BULLET_DMG) / 10;
                else if (item.stat === 'fireRate') currentLevel = (BASE_FIRE_RATE - currentVal) / 0.5;
                else if (item.stat === 'moveSpeed') currentLevel = (currentVal - BASE_MOVE_SPEED) / 0.5;
                else if (item.stat === 'maxLives') currentLevel = currentVal - BASE_MAX_LIVES;
                
                const currentCost = item.baseCost + currentLevel * 50; 
                const buttonText = item.type === 'heal' ? `ÂõûÂæ© ${item.baseCost}G` : `Âº∑Âåñ ${currentCost}G`;
                const isDisabled = stats.gold < currentCost || (item.stat === 'lives' && stats.lives >= stats.maxLives);
                const nextVal = item.stat === 'fireRate' ? Math.max(item.min || 1, currentVal + item.step) : currentVal + item.step;
                const detailText = item.type === 'heal' ? item.desc : `ÁèæÂú®„ÅÆÂÄ§: ${currentVal.toFixed(1)} ‚Üí Next: ${nextVal.toFixed(1)}`;

                html += `<div class="shop-item">
                            <div>${item.name} <span style="font-size:0.8em; color:#bbb;">(Lv.${currentLevel})</span></div>
                            <div class="details">${detailText}</div>
                            <button onclick="buyUpgrade('${key}', ${currentCost})" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
                        </div>`;
            });
            html += `</div>`;
            
            // 2. „Çπ„Ç≠„É´„Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ
            html += `<div class="shop-panel"><h3>‚ö° „Çπ„Ç≠„É´„É¨„Éô„É´„Ç¢„ÉÉ„Éó</h3>`;
            Object.keys(skillData).forEach(skillId => {
                const skill = skillData[skillId];
                const nextLevel = skill.level + 1;
                const currentCost = skill.cost + skill.level * 100;
                const isDisabled = stats.gold < currentCost || skill.level >= skill.maxLevel;
                const buttonText = skill.level >= skill.maxLevel ? "MAX" : `LvUP ${currentCost}G`;
                
                const nextCD = (skill.cd * (1 - nextLevel * 0.05) / 60).toFixed(1);
                const detailText = `Lv.${skill.level} / ${skill.maxLevel} (CD: ${(skill.cd * (1 - skill.level * 0.05) / 60).toFixed(1)}s ‚Üí ${nextCD}s)`;
                
                html += `<div class="shop-item">
                            <div>${skillId} (${skill.key.toUpperCase()}„Ç≠„Éº)</div>
                            <div class="details">${detailText}</div>
                            <button onclick="buySkillUpgrade('${skillId}', ${currentCost})" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
                        </div>`;
            });
            html += `</div>`;

            html += `<button onclick="closeShop()" style="padding: 15px 30px; font-size: 1.5em; background: #76FF03; color: black; border: none; border-radius: 5px; margin-top: 20px;">WAVE ${currentWave + 1} „Å∏</button>`;
            
            shopContainer.innerHTML = html;
        }

        function buyUpgrade(itemId, cost) {
            if (stats.gold < cost) return;
            
            const item = SHOP_ITEMS[itemId];
            
            if (item.type === 'heal') {
                if (stats.lives >= stats.maxLives) return;
                stats.lives = Math.min(stats.maxLives, stats.lives + item.step);
            } else {
                if (item.stat === 'fireRate' && stats.fireRate <= item.min) return;
                stats[item.stat] += item.step;
                if (item.stat === 'fireRate') stats.fireRate = Math.max(item.min, stats.fireRate);
            }

            stats.gold -= cost;
            updateShopDisplay();
        }
        
        function buySkillUpgrade(skillId, cost) {
            if (stats.gold < cost) return;
            const skill = skillData[skillId];
            if (skill.level >= skill.maxLevel) return;

            skill.level++;
            stats.gold -= cost;
            updateShopDisplay();
        }
        
        function updateShopDisplay() {
            document.getElementById('shop-container').innerHTML = ''; // ‰∏ÄÂ∫¶„ÇØ„É™„Ç¢
            showShop(); // ÂÜçÊèèÁîª
            updateDisplay();
        }

        function closeShop() {
            document.getElementById('shop-container').style.display = 'none';
            gameStatus = 'playing';
            initGame(currentWave + 1);
        }

        // --- „É°„Ç§„É≥„Ç≤„Éº„É†„É´„Éº„Éó ---

        function gameLoop() {
            if (gameStatus !== 'playing') return;
            gameFrame++; 
            ctx.textAlign = 'start';

            playerShoot(); 
            updateSkills(); 

            player.update();
            enemy.update();
            checkCollisions();

            // ÊèèÁîª
            ctx.clearRect(0, 0, WIDTH, HEIGHT); 
            ctx.fillStyle = '#00001a';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            enemy.draw(); 
            items.forEach(item => item.draw());
            player.draw();
            playerBullets.forEach(bullet => bullet.draw());
            enemyBullets.forEach(bullet => bullet.draw());
            drawTraceLaser();
            
            drawHUD(); // „Éó„É¨„Ç§„É§„ÉºHP„Å®„Çπ„Ç≠„É´CD„ÇíÊèèÁîª

            requestAnimationFrame(gameLoop);
        }

        // --- „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº ---
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            const key = e.key.toLowerCase();
            
            // „Çπ„Ç≠„É´Áô∫Âãï„Ç≠„Éº
            if (gameStatus === 'playing') {
                if (key === 'j') activateSkill(equippedSkills[0]);
                else if (key === 'k') activateSkill(equippedSkills[1]);
                else if (key === 'l') activateSkill(equippedSkills[2]);
            }

            // WASD/ÁßªÂãï/‰ΩéÈÄü„Ç≠„Éº„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂãï‰Ωú„ÇíÈò≤„Åê
            if (key === 'w' || key === 'a' || key === 's' || key === 'd' || key === 'shift' || key === 'z' || key === ' ' || key.includes('arrow')) {
                e.preventDefault(); 
            }

            if (gameStatus === 'gameover' && key === 'r') {
                // R„Ç≠„Éº„Åß„É™„Çπ„Çø„Éº„ÉàÊôÇ„ÅÆÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
                stats = {
                    gold: 0,
                    lives: BASE_MAX_LIVES,
                    maxLives: BASE_MAX_LIVES,
                    bulletDmg: BASE_BULLET_DMG,
                    fireRate: BASE_FIRE_RATE,
                    moveSpeed: BASE_MOVE_SPEED,
                };
                Object.keys(skillData).forEach(id => {
                    skillData[id].level = 0;
                    skillData[id].currentCd = 0;
                });
                
                document.getElementById('start-screen').style.display = 'flex';
                gameStatus = 'init';
                return;
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // --- „Éâ„É©„ÉÉ„Ç∞/„Çø„ÉÉ„ÉÅÊìç‰Ωú (ÁúÅÁï•„ÄÅÂâçÂõû„Å®ÂêåÊßò) ---
        function getCanvasMousePosition(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            return { x, y };
        }

        function handleDragStart(event) {
            if (gameStatus !== 'playing') return;
            const pos = getCanvasMousePosition(event);
            
            dragOffsetX = pos.x - player.getCenter().x;
            dragOffsetY = pos.y - player.getCenter().y;
            
            isDragging = true;
            keys['Shift'] = true; // „Éâ„É©„ÉÉ„Ç∞‰∏≠„ÅØËá™ÂãïÁöÑ„Å´‰ΩéÈÄüÁßªÂãï„ÇíON
            event.preventDefault(); 
        }

        function handleDragMove(event) {
            if (!isDragging || gameStatus !== 'playing') return;
            const pos = getCanvasMousePosition(event);
            
            let newX = pos.x - dragOffsetX - player.width / 2;
            let newY = pos.y - dragOffsetY - player.height / 2;

            newX = Math.max(0, Math.min(newX, WIDTH - player.width));
            newY = Math.max(0, Math.min(newY, HEIGHT - player.height));
            
            player.x = newX;
            player.y = newY;
            
            event.preventDefault(); 
        }

        function handleDragEnd() {
            isDragging = false;
            keys['Shift'] = false; // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫Ü„Åß‰ΩéÈÄüÁßªÂãï„ÇíOFF
        }

        // PCÂêë„Åë„Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà
        canvas.addEventListener('mousedown', handleDragStart);
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);

        // „Çπ„Éû„Éõ/„Çø„Éñ„É¨„ÉÉ„ÉàÂêë„Åë„Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà
        canvas.addEventListener('touchstart', handleDragStart);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', handleDragEnd);


    </script>
</body>
</html>
