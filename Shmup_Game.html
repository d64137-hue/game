<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ğŸŒŒ Waveã‚µãƒã‚¤ãƒãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚° (æœ€çµ‚èª¿æ•´ç‰ˆ)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            background: #2a2a2a; 
            color: white; 
            text-align: center; 
            font-family: sans-serif; 
            margin: 0; 
            padding-top: 20px; 
            padding-bottom: 50px; 
            overflow-y: auto;
        }
        h1 {
            color: #76FF03;
            margin-bottom: 20px;
        }
        #NewGameArea {
            max-width: 600px; 
            margin: 0 auto;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #1e1e1e;
        }
        #NewGameCanvas {
            background: #00001a;
            border: 2px solid #76FF03;
            display: block;
            margin: 20px auto;
            cursor: pointer; 
            touch-action: none; 
        }
        #game-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #76FF03;
        }
        /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; justify-content: center; align-items: center;
        }
        /* ã‚·ãƒ§ãƒƒãƒ—/æ°¸ç¶šã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .shop-panel, .perm-panel {
            background: #333;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            width: 90%;
            max-width: 500px;
            text-align: left;
        }
        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px dashed #555;
        }
        .shop-item button {
            padding: 8px 15px;
            background-color: #76FF03;
            color: #1e1e1e;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.1s;
        }
        .shop-item button:disabled {
            background-color: #555;
            color: #aaa;
            cursor: not-allowed;
        }
        .shop-item .details {
            font-size: 0.9em;
            color: #ccc;
        }
        .crystal-upgrade-button {
            background-color: #1E90FF !important; /* é’è‰² */
            color: white !important;
        }
        #reset-button {
            margin-top: 15px; 
            padding: 10px 15px; 
            background-color: #FF4136; 
            color: white; 
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="NewGameArea">
        <h1>ğŸŒŒ Waveã‚µãƒã‚¤ãƒãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚° (é«˜å¯†åº¦å¼¾å¹•)</h1>
        
        <div id="game-info">
            Wave: <span id="wave-display">1</span> | GOLD: <span id="gold-display">0</span> | CRYSTAL: <span id="crystal-display">0</span>
        </div>

        <div style="position: relative;">
            <canvas id="NewGameCanvas" width="500" height="650"></canvas>
            
            <div id="overlay">
                <div id="start-screen" style="background: rgba(0, 0, 0, 0.9); padding: 40px; border-radius: 10px; text-align: center;">
                    <h2>Waveã‚µãƒã‚¤ãƒãƒ«é–‹å§‹ï¼</h2>
                    <p>WASD/çŸ¢å°ã‚­ãƒ¼ã§ç§»å‹•ã€X/ã‚¹ãƒšãƒ¼ã‚¹ã§æ”»æ’ƒã€‚<br>J(å›å¾©), K(é€£å°„), L(ãƒãƒªã‚¢)ã§ã‚¹ã‚­ãƒ«ç™ºå‹•ï¼<br>Shift/Zã§**ç²¾å¯†å›é¿ãƒ¢ãƒ¼ãƒ‰**</p>
                    <button onclick="startGame()" style="padding: 15px 30px; font-size: 1.5em; background: #76FF03; color: black; border: none; border-radius: 5px; margin-top: 20px;">ã‚¹ã‚¿ãƒ¼ãƒˆ WAVE 1</button>
                </div>

                <div id="shop-container" style="display: none; background: rgba(0, 0, 0, 0.9); padding: 20px; box-sizing: border-box; flex-direction: column; align-items: center;">
                    </div>
                
                <div id="perm-upgrade-container" style="display: none; background: rgba(0, 0, 0, 0.9); padding: 20px; box-sizing: border-box; flex-direction: column; align-items: center;">
                    </div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('NewGameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;

        // --- localStorageã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ãƒ­ãƒ¼ãƒ‰ ---
        const load = (key, defaultValue) => JSON.parse(localStorage.getItem(key)) || defaultValue;
        const save = (key, value) => localStorage.setItem(key, JSON.stringify(value));

        // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹å¤‰æ•° ---
        let gameStatus = 'init'; // 'init', 'playing', 'shop', 'gameover'
        let currentWave = 0;
        let keys = {};
        let player;
        let enemy;
        let playerBullets = [];
        let enemyBullets = [];
        let items = []; 
        let gameFrame = 0;
        let isDragging = false; 
        
        // --- æ°¸ç¶šã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ (ã‚¯ãƒªã‚¹ã‚¿ãƒ«é€šè²¨) ---
        const defaultPermStats = {
            goldMultiplier: 1,      
            baseMaxHp: 150,         
            baseDmgBonus: 0,        
        };
        const PERM_STATS = load('permStats', defaultPermStats);
        
        // --- ã‚²ãƒ¼ãƒ å®šæ•°ã¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚·ã‚¹ãƒ†ãƒ  ---
        const BASE_FIRE_RATE = 8;
        const BASE_MOVE_SPEED = 4.5;
        const BASE_BULLET_DMG = 10;
        const BASE_HEAL_AMOUNT = 50; 
        
        let stats = {
            gold: 0,
            crystal: load('crystal', 0), 
            maxHp: PERM_STATS.baseMaxHp,
            currentHp: PERM_STATS.baseMaxHp,
            bulletDmg: BASE_BULLET_DMG + PERM_STATS.baseDmgBonus,
            fireRate: BASE_FIRE_RATE,
            moveSpeed: BASE_MOVE_SPEED,
        };

        // ã‚¹ã‚­ãƒ«ãƒ‡ãƒ¼ã‚¿
        let skillData = {
            HEAL: { name: "ãƒªã‚«ãƒãƒªãƒ¼ (J)", cd: 60 * 1.5, currentCd: 0, cost: 200, key: 'j', level: 0, maxLevel: 5 },
            FULL_BURST: { name: "ãƒ•ãƒ«ãƒãƒ¼ã‚¹ãƒˆ (K)", cd: 60 * 0.75, currentCd: 0, cost: 150, key: 'k', level: 0, maxLevel: 5 },
            BARRIER: { name: "ãƒãƒªã‚¢ (L)", cd: 60 * 2, currentCd: 0, cost: 300, key: 'l', level: 0, maxLevel: 5 }
        };
        let equippedSkills = ['HEAL', 'FULL_BURST', 'BARRIER']; 
        
        // ã‚¹ã‚­ãƒ«ç™ºå‹•ä¸­ã®çŠ¶æ…‹
        let skillEffects = {
            fullBurst: 0, 
            barrier: 0,
        };

        const SHOP_ITEMS = {
            BULLET_DMG: { name: "ç«åŠ›ã‚¢ãƒƒãƒ—", type: "stat", desc: "å¼¾ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ  +5", baseCost: 100, stat: 'bulletDmg', step: 5, fixedLevel: 0 },
            FIRE_RATE: { name: "é€£å°„é€Ÿåº¦ã‚¢ãƒƒãƒ—", type: "stat", desc: "é€£å°„é–“éš” -0.5f", baseCost: 150, stat: 'fireRate', step: -0.5, min: 2, fixedLevel: 0 },
            MOVE_SPEED: { name: "ç§»å‹•é€Ÿåº¦ã‚¢ãƒƒãƒ—", type: "stat", desc: "ç§»å‹•é€Ÿåº¦ +0.5", baseCost: 100, stat: 'moveSpeed', step: 0.5, fixedLevel: 0 },
            MAX_HP: { name: "æœ€å¤§HPã‚¢ãƒƒãƒ—", type: "stat", desc: "æœ€å¤§HP +10", baseCost: 200, stat: 'maxHp', step: 10, fixedLevel: 0 },
            HEAL_CURRENT: { name: "HPå›å¾©", type: "heal", desc: `HPã‚’ ${BASE_HEAL_AMOUNT} å›å¾©`, baseCost: 100, stat: 'currentHp', step: BASE_HEAL_AMOUNT, fixedLevel: 0 }
        };
        
        const PERM_UPGRADES = {
            GOLD_MULTI: { name: "GOLDç²å¾—é‡", desc: "+10% (æ°¸ç¶š)", stat: 'goldMultiplier', step: 0.1, max: 5, costBase: 1, costMulti: 1.5 },
            BASE_HP: { name: "åˆæœŸHP", desc: "+10 (æ°¸ç¶š)", stat: 'baseMaxHp', step: 10, max: 10, costBase: 2, costMulti: 2 },
            BASE_DMG: { name: "åˆæœŸç«åŠ›", desc: "+5 (æ°¸ç¶š)", stat: 'baseDmgBonus', step: 5, max: 10, costBase: 3, costMulti: 1.8 }
        };


        // --- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹ ---
        class Player {
            constructor() {
                this.width = 20; 
                this.height = 20;
                this.x = WIDTH / 2 - this.width / 2;
                this.y = HEIGHT - this.height - 10;
                this.color = 'cyan';
                this.hitRadius = 3; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹åŠå¾„
                this.currentHp = stats.currentHp;
                this.iFrames = 0; // ç„¡æ•µæ™‚é–“ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ (ãƒ•ãƒ¬ãƒ¼ãƒ )
            }

            update() {
                if (isDragging) return; 

                const isSlow = keys['Shift'] || keys['z']; 
                let currentSpeed = stats.moveSpeed;
                if (isSlow) currentSpeed = stats.moveSpeed * 0.2; 

                if (keys['ArrowLeft'] || keys['a']) this.x -= currentSpeed;
                if (keys['ArrowRight'] || keys['d']) this.x += currentSpeed;
                if (keys['ArrowUp'] || keys['w']) this.y -= currentSpeed; 
                if (keys['ArrowDown'] || keys['s']) this.y += currentSpeed; 

                this.x = Math.max(0, Math.min(this.x, WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, HEIGHT - this.height));

                if (this.iFrames > 0) this.iFrames--; // ç„¡æ•µæ™‚é–“ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³
            }
            
            takeDamage(damage) {
                if (skillEffects.barrier > 0 || this.iFrames > 0) return; // ç„¡æ•µæ™‚é–“ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ç„¡åŠ¹

                this.currentHp -= damage;
                stats.currentHp = this.currentHp; // ğŸ”¥ ä¿®æ­£: HPã‚’æ¸›ã‚‰ã—ãŸç›´å¾Œã«statsã‚’æ›´æ–°

                this.iFrames = 20; // 20ãƒ•ãƒ¬ãƒ¼ãƒ  (ç´„0.33ç§’) ã®ç„¡æ•µæ™‚é–“ã‚’ä»˜ä¸

                // ãƒã‚°ä¿®æ­£: HPãŒ0ä»¥ä¸‹ã«ãªã£ãŸã‚‰ç›´ã¡ã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šã‚’è¡Œã†
                if (this.currentHp <= 0) {
                    this.currentHp = 0; // HPã‚’0ã«å›ºå®š
                    stats.currentHp = 0; // å†åº¦ç¢ºå®Ÿã«0ã«ã™ã‚‹
                    gameOver();
                }
            }
            
            // HPã‚²ãƒ¼ã‚¸ã®æç”»
            drawHealthBar() {
                const pBarWidth = 150;
                const pBarHeight = 15;
                const pBarX = WIDTH - pBarWidth - 10;
                const pBarY = HEIGHT - pBarHeight - 10;
                // HPè¡¨ç¤ºã‚‚å¸¸ã«stats.currentHpã‹ã‚‰å–å¾—
                const pRatio = Math.max(0, stats.currentHp) / stats.maxHp; 

                ctx.fillStyle = '#444';
                ctx.fillRect(pBarX, pBarY, pBarWidth, pBarHeight);
                ctx.fillStyle = '#1E90FF'; 
                ctx.fillRect(pBarX, pBarY, pBarWidth * pRatio, pBarHeight);
                
                ctx.strokeStyle = 'white';
                ctx.strokeRect(pBarX, pBarY, pBarWidth, pBarHeight);
                
                ctx.fillStyle = 'white';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(`HP: ${Math.max(0, Math.floor(stats.currentHp))}/${stats.maxHp}`, pBarX + pBarWidth, pBarY - 5);
            }

            draw() {
                const isSlow = keys['Shift'] || keys['z'];
                const center = this.getCenter();
                const isInvincible = skillEffects.barrier > 0;

                // æç”»è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
                ctx.globalAlpha = 1.0; 

                // 1. ãƒãƒªã‚¢ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                if (isInvincible) {
                    ctx.fillStyle = `rgba(30, 144, 255, ${gameFrame % 10 < 5 ? 0.7 : 0.4})`;
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, 25, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ç„¡æ•µæ™‚é–“ä¸­ã®ç‚¹æ»…å‡¦ç†
                if (this.iFrames > 0) {
                    if (gameFrame % 5 < 2) { // ã‚ãšã‹ãªç‚¹æ»…ã§ç„¡æ•µã‚’è¡¨ç¤º
                        ctx.globalAlpha = 0.3; 
                    }
                }

                // 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬ä½“ï¼ˆä¸‰è§’å½¢ï¼‰
                ctx.fillStyle = isSlow ? '#B2FF59' : this.color; 
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.closePath();
                ctx.fill();

                if (isSlow) {
                    ctx.strokeStyle = '#76FF03';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // 3. å½“ãŸã‚Šåˆ¤å®šï¼ˆé»„è‰²ã„ç‚¹ï¼‰
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’æç”»
                ctx.fillStyle = isSlow ? 'yellow' : 'red';
                ctx.beginPath();
                ctx.arc(center.x, center.y, this.hitRadius + 1, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1.0; // æç”»å¾Œã«å…ƒã«æˆ»ã™
                
                this.drawHealthBar();
            }

            getCenter() {
                return { x: this.x + this.width / 2, y: this.y + this.height / 2, radius: this.hitRadius };
            }
        }

        class PlayerBullet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.speed = 10;
                this.damage = stats.bulletDmg;
                this.color = 'yellow';
                if (skillEffects.fullBurst > 0) this.color = 'red'; 
            }

            update() {
                this.y -= this.speed;
                return this.y < 0; 
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        class Enemy {
            constructor(initialHP) {
                this.width = 40;
                this.height = 40;
                this.x = WIDTH / 2 - this.width / 2;
                this.y = 50; 
                this.color = 'red';
                this.maxHealth = initialHP;
                this.health = initialHP;
                this.fireTimer = 0;
                this.firePattern = 0; 
                this.patternInterval = 60; 
                this.isBoss = currentWave % 5 === 0;
            }

            update() {
                this.x = WIDTH / 2 + Math.sin(gameFrame * 0.01) * 50 * (this.isBoss ? 1.5 : 0);
                this.x = Math.max(0, Math.min(this.x, WIDTH - this.width));

                this.fireTimer++;
                
                let baseInterval = this.isBoss ? 45 : 60; // ãƒœã‚¹ã¯ç™ºå°„é–“éš”ã‚’ã•ã‚‰ã«çŸ­ç¸®
                
                if (this.fireTimer > baseInterval + Math.random() * 20) {
                    this.fireTimer = 0;
                    // ãƒœã‚¹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³æ•°ã‚’12ã«èª¿æ•´
                    this.firePattern = Math.floor(Math.random() * (this.isBoss ? 12 : 9)); 
                    this.shoot();
                }

                return this.health <= 0; 
            }

            shoot() {
                let center = this.getCenter();
                // æ•µå¼¾ã®åŸºæœ¬é€Ÿåº¦ã‚’èª¿æ•´ (Wave10ãƒœã‚¹ã«å¯¾å¿œ)
                let speed = 2.5 + (currentWave / 10); 
                
                // æœ€å¤§é€Ÿåº¦ã‚’èª¿æ•´
                speed = Math.min(speed, 6.5); 
                
                let num, angleStep, startAngle;
                
                // WaveãŒé€²ã‚€ã«ã¤ã‚Œã¦å¼¾æ•°ã‚’å¢—ã‚„ã—ã€å¯†åº¦ã‚’ä¸Šã’ã‚‹
                let bulletDensity = 1 + Math.floor(currentWave / 5); 

                switch (this.firePattern) {
                    case 0: // 5æ–¹å‘æ‹¡æ•£å¼¾ (èµ¤: æ¨™æº–)
                        num = 5 + bulletDensity * 2; 
                        angleStep = Math.PI * 0.2; 
                        startAngle = Math.PI / 2 - angleStep * (num - 1) / 2;
                        for (let i = 0; i < num; i++) {
                            let angle = startAngle + i * angleStep;
                            let dx = Math.cos(angle) * speed;
                            let dy = Math.sin(angle) * speed;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 3 ã«èª¿æ•´ (5 -> 3)
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'red', dx, 3));
                        }
                        break;
                    case 1: // æ™‚è¨ˆå›ã‚Šèºæ—‹å¼¾ (ç´«: ç·©é€Ÿã€é«˜å¯†åº¦)
                        num = 12 + bulletDensity * 3;
                        angleStep = Math.PI * 2 / num;
                        for (let i = 0; i < num; i++) {
                            let angle = i * angleStep + gameFrame * 0.05;
                            let dx = Math.cos(angle) * speed * 0.6;
                            let dy = Math.sin(angle) * speed * 0.6;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 2 ã«èª¿æ•´ (3 -> 2)
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'purple', dx, 2));
                        }
                        break;
                    case 2: // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç‹™ã„è¿½å°¾å¼¾ (ç·‘: ä½é€Ÿè¿½å°¾)
                        if (currentWave >= 2) {
                            let angle = Math.atan2(player.getCenter().y - center.y, player.getCenter().x - center.x);
                            let currentFollowSpeed = Math.min(1.0, 0.8 + currentWave * 0.05); 
                            let dx = Math.cos(angle) * currentFollowSpeed; 
                            let dy = Math.sin(angle) * currentFollowSpeed;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 3 ã«èª¿æ•´ (6 -> 3)
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'lime', dx, 3, 240)); 
                        }
                        break;
                    case 3: // æ”¾å°„çŠ¶ã‚¦ã‚§ãƒ¼ãƒ–å¼¾ (é»„è‰²: æ³¢ç´‹)
                        num = 18 + bulletDensity * 4;
                        for (let i = 0; i < num; i++) {
                            let angle = (i * (360 / num) + gameFrame * 0.5) * (Math.PI / 180);
                            let dx = Math.cos(angle) * speed * 0.7;
                            let dy = Math.sin(angle) * speed * 0.7;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 3 ã«èª¿æ•´ (4 -> 3)
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'yellow', dx, 3));
                        }
                        break;
                    case 4: // Vå­—å¼¾ (é’: é«˜é€Ÿ)
                        num = 3 + bulletDensity;
                        angleStep = Math.PI * 0.08; 
                        startAngle = Math.atan2(player.getCenter().y - center.y, player.getCenter().x - center.x) - angleStep * (num - 1) / 2;
                        for (let i = 0; i < num; i++) {
                            let angle = startAngle + i * angleStep;
                            let highSpeed = Math.min(speed * 1.3, 7.5); 
                            let dx = Math.cos(angle) * highSpeed;
                            let dy = Math.sin(angle) * highSpeed;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 2 ã«èª¿æ•´ (3 -> 2)
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'blue', dx, 2));
                        }
                        break;
                    case 5: // çŸ©å½¢å¼¾ (ã‚ªãƒ¬ãƒ³ã‚¸: ä½é€Ÿã§ç›´é€²)
                        num = 4 + bulletDensity;
                        for (let i = 0; i < num; i++) {
                            let dx = (i % 2 === 0 ? speed * 0.5 : 0) * (Math.random() > 0.5 ? 1 : -1);
                            let dy = (i % 2 !== 0 ? speed * 0.5 : 0) * speed * 0.5;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 3 ã«èª¿æ•´ (8 -> 3)
                            enemyBullets.push(new EnemyBullet(center.x + (i % 2 === 0 ? 0 : 20), center.y, dy, 'orange', dx, 3, 0, true));
                        }
                        break;
                    case 6: // ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘ã¸ã®é«˜é€Ÿå¼¾ (ç™½è‰²)
                        num = 6 + bulletDensity * 2;
                        for (let i = 0; i < num; i++) {
                            let angle = Math.random() * Math.PI * 2;
                            let s = speed * (1.2 + Math.random() * 0.3); 
                            let dx = Math.cos(angle) * s;
                            let dy = Math.sin(angle) * s;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 2 ã«èª¿æ•´ (3 -> 2)
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, 'white', dx, 2));
                        }
                        break;
                    case 7: // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨ä½ç½®ã¸ã®èª˜å°å¼¾ (èµ¤è‰²ã€é«˜é€Ÿ)
                        if (currentWave >= 3) {
                            let angle = Math.atan2(player.getCenter().y - center.y, player.getCenter().x - center.x);
                            let fastTargetSpeed = Math.min(speed * 1.0, 6.0);
                            let dx = Math.cos(angle) * fastTargetSpeed;
                            let dy = Math.sin(angle) * fastTargetSpeed;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 3 ã«èª¿æ•´ (4 -> 3)
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy, '#FF5733', dx, 3)); 
                            enemyBullets.push(new EnemyBullet(center.x, center.y, dy * 0.5, '#FF5733', dx * 0.5, 3)); 
                        }
                        break;
                    case 8: // (æ–°) åºƒç¯„å›²åå°„å¼¾ (ãƒ”ãƒ³ã‚¯: å·¦å³ç«¯ã§è·³ã­ã‚‹) - åå°„å›æ•°4
                        num = 8 + bulletDensity;
                        for (let i = 0; i < num; i++) {
                            let startX = center.x + (i - num/2) * 20; 
                            let angle = Math.atan2(player.getCenter().y - center.y, player.getCenter().x - startX);
                            let dx = Math.cos(angle) * speed * 0.8;
                            let dy = Math.sin(angle) * speed * 0.8;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 3 ã«èª¿æ•´ (4 -> 3)
                            enemyBullets.push(new EnemyBullet(startX, center.y, dy, 'pink', dx, 3, 0, false, 4));
                        }
                        break;
                    case 9: // ã‚«ãƒ¼ãƒ†ãƒ³ (ä¸Šä¸‹å·¦å³ã«ãšã‚ŒãŸãƒ©ã‚¤ãƒ³) - åŠå¾„4
                        num = 10 + bulletDensity * 2;
                        for (let i = 0; i < num; i++) {
                            let dx = 0;
                            let dy = speed * 0.4;
                            let spawnX = (WIDTH / num) * i + Math.sin(gameFrame * 0.1) * 10;
                            // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 3 ã«èª¿æ•´ (4 -> 3)
                            enemyBullets.push(new EnemyBullet(spawnX, 0, dy, 'gray', dx, 3)); 
                        }
                        break;
                    case 10: // (ãƒœã‚¹) ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒªãƒ³ã‚°
                        if (this.isBoss) {
                            num = 15 + bulletDensity * 3;
                            let center = player.getCenter();
                            for (let i = 0; i < num; i++) {
                                let angle = i * Math.PI * 2 / num;
                                let dx = Math.cos(angle) * speed * 0.6;
                                let dy = Math.sin(angle) * speed * 0.6;
                                // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 3 ã«èª¿æ•´ (5 -> 3)
                                enemyBullets.push(new EnemyBullet(center.x, center.y, dy, '#FFC300', dx, 3));
                            }
                        }
                        break;
                    case 11: // (ãƒœã‚¹) 8æ–¹å‘ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚§ãƒ¼ãƒ–
                        if (this.isBoss) {
                            num = 8;
                            for (let j = 0; j < 4; j++) { 
                                for (let i = 0; i < num; i++) {
                                    let angle = (i * Math.PI / 4) + Math.sin(gameFrame * 0.05 + j * 10) * 0.2;
                                    let s = speed * 0.5 + j * 0.3;
                                    let dx = Math.cos(angle) * s;
                                    let dy = Math.sin(angle) * s;
                                    // ğŸ”¥ æ•µå¼¾ã®åŠå¾„ã‚’ 2 ã«èª¿æ•´ (3 -> 2)
                                    enemyBullets.push(new EnemyBullet(center.x, center.y, dy, '#900C3F', dx, 2));
                                }
                            }
                        }
                        break;
                }
            }

            draw() {
                ctx.fillStyle = this.isBoss ? 'darkred' : this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                this.drawHealthBar();
            }
            
            drawHealthBar() {
                const barWidth = WIDTH - 40;
                const barHeight = 10;
                const barX = 20;
                const barY = 15;
                const hpRatio = this.health / this.maxHealth;

                ctx.fillStyle = '#444';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                ctx.fillStyle = '#FF4136'; 
                ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
                
                ctx.strokeStyle = 'white';
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                ctx.fillStyle = 'white';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`BOSS HP: ${Math.max(0, Math.floor(this.health))} / ${this.maxHealth}`, WIDTH / 2, barY + barHeight + 10);
                
            }

            getCenter() {
                return { x: this.x + this.width / 2, y: this.y + this.height / 2, radius: this.width / 2 };
            }
        }

        class EnemyBullet {
            constructor(x, y, dy, color = 'red', dx = 0, radius = 5, followDuration = 0, isSquare = false, bounce = 0) {
                this.x = x;
                this.y = y;
                this.radius = radius; // æ•µå¼¾ã®å½“ãŸã‚Šåˆ¤å®šåŠå¾„
                this.baseDx = dx;
                this.baseDy = dy;
                this.color = color;
                this.followDuration = followDuration;
                this.frames = 0;
                this.isSquare = isSquare;
                this.bounce = bounce;
            }

            update() {
                this.frames++;
                
                let dx = this.baseDx;
                let dy = this.baseDy;

                // è¿½å°¾å¼¾å‡¦ç†
                if (this.frames < this.followDuration) {
                    let target = player.getCenter();
                    let angle = Math.atan2(target.y - this.y, target.x - this.x);
                    let speed = Math.sqrt(this.baseDx * this.baseDx + this.baseDy * this.baseDy);
                    
                    dx = Math.cos(angle) * speed;
                    dy = Math.sin(angle) * speed;
                }

                this.y += dy;
                this.x += dx; 
                
                // ãƒã‚¦ãƒ³ãƒ‰å‡¦ç†
                if (this.bounce > 0) {
                    let bounced = false;
                    
                    if (this.x - this.radius < 0) {
                        this.baseDx = Math.abs(this.baseDx);
                        bounced = true;
                    } else if (this.x + this.radius > WIDTH) {
                        this.baseDx = -Math.abs(this.baseDx);
                        bounced = true;
                    }
                    
                    if (this.y - this.radius < 0) {
                        this.baseDy = Math.abs(this.baseDy);
                        bounced = true;
                    } else if (this.y + this.radius > HEIGHT) {
                        this.baseDy = -Math.abs(this.baseDy);
                        bounced = true;
                    }
                    
                    if (bounced) this.bounce--;
                }


                return this.y > HEIGHT || this.y < 0 || this.x < 0 || this.x > WIDTH;
            }

            draw() {
                ctx.fillStyle = this.color;
                if (this.isSquare) {
                    // å››è§’å½¢å¼¾ã®å ´åˆã‚‚ this.radius ã‚’ä½¿ã£ã¦æç”»
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                } else {
                    // å††å½¢å¼¾ã®å ´åˆ
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        class Item {
            constructor(x, y, value) {
                this.x = x;
                this.y = y;
                this.value = value;
                this.radius = 5;
                this.color = 'gold';
            }
            
            update() {
                this.y += 1; 
                return this.y > HEIGHT;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // --- ã‚²ãƒ¼ãƒ ç®¡ç†é–¢æ•° ---

        function startGame() {
            document.getElementById('overlay').style.display = 'none';
            gameStatus = 'playing';
            initGame(1);
        }

        function initGame(wave) {
            currentWave = wave;
            
            // æ•µã®åˆæœŸåŒ– (HPã®ä¸Šæ˜‡ç‡ã‚’ç·©ã‚„ã‹ã«)
            const baseHP = 500;
            const hpMultiplier = 1.25; 
            let initialHP = Math.floor(baseHP * Math.pow(hpMultiplier, currentWave - 1));
            
            if (currentWave % 5 === 0) { 
                initialHP *= 2.5; 
            } else {
                initialHP = Math.floor(initialHP / 5); 
            }
            initialHP = Math.max(50, initialHP);
            
            enemy = new Enemy(initialHP);
            player = new Player();
            player.currentHp = stats.currentHp; // æ°¸ç¶šå€¤ã‹ã‚‰HPã‚’ãƒ­ãƒ¼ãƒ‰
            
            playerBullets = [];
            enemyBullets = [];
            items = [];
            gameFrame = 0;
            
            Object.values(skillData).forEach(s => s.currentCd = 0); 
            
            updateDisplay();
            if (gameStatus === 'playing') {
                gameLoop();
            }
        }
        
        function startNextWave() {
            // Waveã‚¯ãƒªã‚¢ãƒœãƒ¼ãƒŠã‚¹
            let baseGold = 100 + currentWave * 20;
            let bonusGold = Math.floor(baseGold * PERM_STATS.goldMultiplier);
            stats.gold += bonusGold;
            
            if (currentWave % 5 === 0) {
                // ãƒœã‚¹æ’ƒç ´ã§ã‚¯ãƒªã‚¹ã‚¿ãƒ«ç²å¾—
                let baseCrystal = 1;
                let crystalMultiplier = currentWave >= 30 ? 3 : currentWave >= 15 ? 2 : 1;
                let gainedCrystal = Math.max(1, Math.floor(baseCrystal * crystalMultiplier));
                
                stats.crystal += gainedCrystal;
                // ã‚¯ãƒªã‚¹ã‚¿ãƒ«æ®‹é«˜ã‚’ä¿å­˜
                save('crystal', stats.crystal); 
                alert(`BOSS DEFEATED! \nã‚¯ãƒªã‚¹ã‚¿ãƒ«ã‚’ ${gainedCrystal} å€‹ç²å¾—ã—ã¾ã—ãŸï¼`);
            }
            
            // ã‚·ãƒ§ãƒƒãƒ—ã¸ç§»è¡Œ
            gameStatus = 'shop';
            showShop();
        }

        function checkCollisions() {
            // 1. è‡ªæ©Ÿå¼¾ vs æ•µ (çœç•¥ - å¤‰æ›´ãªã—)
            playerBullets = playerBullets.filter(bullet => {
                const dist = Math.sqrt(Math.pow(bullet.x - enemy.getCenter().x, 2) + Math.pow(bullet.y - enemy.getCenter().y, 2));
                if (dist < bullet.radius + enemy.width / 2) {
                    enemy.health -= bullet.damage; 
                    
                    if (!enemy.isBoss && Math.random() < 0.05) {
                        items.push(new Item(bullet.x, bullet.y, 5));
                    }

                    if (enemy.health <= 0) {
                        startNextWave();
                        return false; 
                    }
                    return false; 
                }
                return !bullet.update();
            });

            // 2. æ•µå¼¾ vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            enemyBullets = enemyBullets.filter(bullet => {
                const playerCenter = player.getCenter();
                const dist = Math.sqrt(Math.pow(bullet.x - playerCenter.x, 2) + Math.pow(bullet.y - playerCenter.y, 2));
                
                if (dist < bullet.radius + playerCenter.radius) {
                    
                    // ğŸ”¥ã€å¤šé‡ãƒ’ãƒƒãƒˆå¯¾ç­–: ç„¡æ•µ/ãƒãƒªã‚¢ã§å¼¾ã‚’æ¶ˆã™ã€‘
                    if (skillEffects.barrier > 0 || player.iFrames > 0) {
                        return false; // å½“ãŸã£ã¦ã‚‚ãƒ€ãƒ¡ãƒ¼ã‚¸ã¯ç„¡åŠ¹ã€**å¼¾ã¯ç¢ºå®Ÿã«æ¶ˆã™**
                    }
                    
                    // ãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨
                    player.takeDamage(10); 
                    updateDisplay();
                    
                    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã—ãŸå ´åˆã¯ã€ã“ã®å¾Œã®å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
                    if (gameStatus === 'gameover') return false; 
                    return false; // **ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸã‚‰å¼¾ã¯ç¢ºå®Ÿã«æ¶ˆã™**
                }
                return !bullet.update(); 
            });
            
            // 3. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ vs ã‚¢ã‚¤ãƒ†ãƒ  (çœç•¥ - å¤‰æ›´ãªã—)
            items = items.filter(item => {
                const playerCenter = player.getCenter();
                const dist = Math.sqrt(Math.pow(item.x - playerCenter.x, 2) + Math.pow(item.y - playerCenter.y, 2));
                
                if (dist < item.radius + playerCenter.radius + 10) { 
                    stats.gold += item.value;
                    updateDisplay();
                    return false; 
                }
                return !item.update();
            });
        }
        
        function playerShoot() {
            const currentFireRate = stats.fireRate;
            let actualFireRate = currentFireRate;
            let dmgMultiplier = 1;
            
            if (skillEffects.fullBurst > 0) {
                actualFireRate = Math.max(2, currentFireRate / 2); 
                dmgMultiplier = 1.5 + skillData.FULL_BURST.level * 0.1; 
            }

            if (keys[' '] || keys['x']) {
                if (gameFrame % Math.floor(actualFireRate) === 0) {
                    const bulletDmg = stats.bulletDmg * dmgMultiplier;
                    playerBullets.push(new PlayerBullet(player.x + player.width / 2, player.y));
                    playerBullets[playerBullets.length - 1].damage = bulletDmg;
                }
            }
        }
        
        function activateSkill(skillId) {
            const skill = skillData[skillId];
            // HPãŒ0ã®æ™‚ã¯ã‚¹ã‚­ãƒ«ç™ºå‹•ä¸å¯
            if (skill.currentCd > 0 || stats.currentHp <= 0) return;
            
            skill.currentCd = skill.cd * (1 - skill.level * 0.05);
            
            switch(skillId) {
                case 'HEAL':
                    const healAmount = BASE_HEAL_AMOUNT + skill.level * 10;
                    player.currentHp = Math.min(stats.maxHp, player.currentHp + healAmount);
                    stats.currentHp = player.currentHp;
                    updateDisplay();
                    break;
                case 'FULL_BURST':
                    skillEffects.fullBurst = 300 + skill.level * 60; 
                    break;
                case 'BARRIER':
                    skillEffects.barrier = 180 + skill.level * 30; 
                    break;
            }
        }
        
        function updateSkills() {
            Object.values(skillData).forEach(skill => {
                if (skill.currentCd > 0) {
                    skill.currentCd--;
                }
            });
            
            Object.keys(skillEffects).forEach(key => {
                if (skillEffects[key] > 0) {
                    skillEffects[key]--;
                }
            });
        }
        
        function drawHUD() {
            // ã‚¹ã‚­ãƒ«ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚²ãƒ¼ã‚¸
            equippedSkills.forEach((skillId, index) => {
                const skill = skillData[skillId];
                const totalCD = skill.cd * (1 - skill.level * 0.05);
                const cdRatio = skill.currentCd / totalCD;
                const cdBarWidth = 80;
                const cdBarHeight = 10;
                const cdBarX = 10;
                const cdBarY = HEIGHT - 50 - (index * 20);
                
                ctx.fillStyle = '#444';
                ctx.fillRect(cdBarX, cdBarY, cdBarWidth, cdBarHeight);
                
                const skillText = skill.name.split(' ')[0]; 
                
                if (skill.currentCd > 0) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(cdBarX, cdBarY, cdBarWidth * cdRatio, cdBarHeight);
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${skillText} - CD: ${(skill.currentCd / 60).toFixed(1)}s`, cdBarX + cdBarWidth + 5, cdBarY + 9);
                } else {
                    ctx.fillStyle = '#76FF03';
                    ctx.fillRect(cdBarX, cdBarY, cdBarWidth, cdBarHeight);
                    ctx.fillStyle = 'black';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${skillText} - READY`, cdBarX + 5, cdBarY + 9);
                }
                
                ctx.strokeStyle = 'white';
                ctx.strokeRect(cdBarX, cdBarY, cdBarWidth, cdBarHeight);
            });
        }
        
        function gameOver() {
            gameStatus = 'gameover';
            showPermanentUpgrade();
        }

        function updateDisplay() {
            document.getElementById('wave-display').textContent = currentWave;
            document.getElementById('gold-display').textContent = stats.gold;
            document.getElementById('crystal-display').textContent = stats.crystal;
        }
        
        // --- ã‚·ãƒ§ãƒƒãƒ—ç”»é¢ã®è¡¨ç¤ºã¨å‡¦ç† (GOLD) ---
        
        function showShop() {
            const shopContainer = document.getElementById('shop-container');
            document.getElementById('overlay').style.display = 'flex';
            shopContainer.style.display = 'flex';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('perm-upgrade-container').style.display = 'none';
            
            let html = `<h2>Wave ${currentWave} CLEAR!</h2>`;
            html += `<p style="font-size: 1.2em; color: gold;">æ‰€æŒ GOLD: <span id="shop-gold-display">${stats.gold}</span></p><hr>`;
            
            // 1. åŸºæœ¬ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
            html += `<div class="shop-panel"><h3>ğŸ’ª æˆ¦é—˜èƒ½åŠ›ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ (GOLD)</h3>`;
            Object.keys(SHOP_ITEMS).forEach(key => {
                const item = SHOP_ITEMS[key];
                const currentVal = stats[item.stat] !== undefined ? stats[item.stat] : item.step;
                
                let currentLevel = item.fixedLevel;
                if(item.stat === 'bulletDmg') currentLevel = (currentVal - (BASE_BULLET_DMG + PERM_STATS.baseDmgBonus)) / item.step;
                else if(item.stat === 'fireRate') currentLevel = (BASE_FIRE_RATE - currentVal) / -item.step;
                else if(item.stat === 'moveSpeed') currentLevel = (currentVal - BASE_MOVE_SPEED) / item.step;
                else if(item.stat === 'maxHp') currentLevel = (currentVal - PERM_STATS.baseMaxHp) / item.step;
                
                const currentCost = item.baseCost + Math.floor(currentLevel) * 50; // ã‚³ã‚¹ãƒˆè¨ˆç®—ã‚’æ•´æ•°ã«
                const buttonText = item.type === 'heal' ? `å›å¾© ${item.baseCost}G` : `å¼·åŒ– ${currentCost}G`;
                const isDisabled = stats.gold < currentCost || (item.stat === 'currentHp' && stats.currentHp >= stats.maxHp);
                const nextVal = item.stat === 'fireRate' ? Math.max(item.min || 1, currentVal + item.step) : currentVal + item.step;
                const detailText = item.type === 'heal' ? item.desc : `ç¾åœ¨ã®å€¤: ${currentVal.toFixed(1)} â†’ Next: ${nextVal.toFixed(1)}`;

                html += `<div class="shop-item">
                            <div>${item.name} <span style="font-size:0.8em; color:#bbb;">(Lv.${Math.floor(currentLevel)})</span></div>
                            <div class="details">${detailText}</div>
                            <button onclick="buyUpgrade('${key}', ${currentCost})" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
                        </div>`;
                item.fixedLevel = Math.floor(currentLevel);
            });
            html += `</div>`;
            
            // 2. ã‚¹ã‚­ãƒ«ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
            html += `<div class="shop-panel"><h3>âš¡ ã‚¹ã‚­ãƒ«ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ— (GOLD)</h3>`;
            equippedSkills.forEach(skillId => {
                const skill = skillData[skillId];
                const nextLevel = skill.level + 1;
                const currentCost = skill.cost + skill.level * 100;
                const isDisabled = stats.gold < currentCost || skill.level >= skill.maxLevel;
                const buttonText = skill.level >= skill.maxLevel ? "MAX" : `LvUP ${currentCost}G`;
                
                const nextCD = (skill.cd * (1 - nextLevel * 0.05) / 60).toFixed(1);
                const detailText = `Lv.${skill.level} / ${skill.maxLevel} (CD: ${(skill.cd * (1 - skill.level * 0.05) / 60).toFixed(1)}s â†’ ${nextCD}s)`;
                
                html += `<div class="shop-item">
                            <div>${skill.name}</div>
                            <div class="details">${detailText}</div>
                            <button onclick="buySkillUpgrade('${skillId}', ${currentCost})" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
                        </div>`;
            });
            html += `</div>`;

            html += `<button onclick="closeShop()" style="padding: 15px 30px; font-size: 1.5em; background: #76FF03; color: black; border: none; border-radius: 5px; margin-top: 20px;">WAVE ${currentWave + 1} ã¸</button>`;
            
            shopContainer.innerHTML = html;
        }

        function buyUpgrade(itemId, cost) {
            if (stats.gold < cost) return;
            
            const item = SHOP_ITEMS[itemId];
            
            if (item.type === 'heal') {
                if (stats.currentHp >= stats.maxHp) return;
                player.currentHp = Math.min(stats.maxHp, player.currentHp + item.step);
                stats.currentHp = player.currentHp;
            } else {
                if (item.stat === 'fireRate' && stats.fireRate <= item.min) return;
                stats[item.stat] += item.step;
                if (item.stat === 'fireRate') stats.fireRate = Math.max(item.min, stats.fireRate);
            }

            stats.gold -= cost;
            updateShopDisplay();
        }
        
        function buySkillUpgrade(skillId, cost) {
            if (stats.gold < cost) return;
            const skill = skillData[skillId];
            if (skill.level >= skill.maxLevel) return;

            skill.level++;
            stats.gold -= cost;
            updateShopDisplay();
        }
        
        function updateShopDisplay() {
            document.getElementById('shop-container').innerHTML = '';
            showShop();
            updateDisplay();
        }
        
        function closeShop() {
            document.getElementById('overlay').style.display = 'none';
            gameStatus = 'playing';
            initGame(currentWave + 1);
        }
        
        // --- æ°¸ç¶šã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ç”»é¢ã®è¡¨ç¤ºã¨å‡¦ç† (ã‚¯ãƒªã‚¹ã‚¿ãƒ«) ---
        
        function showPermanentUpgrade() {
            const permContainer = document.getElementById('perm-upgrade-container');
            document.getElementById('overlay').style.display = 'flex';
            permContainer.style.display = 'flex';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('shop-container').style.display = 'none';
            
            let html = `<h2>ğŸ˜­ GAME OVER ğŸ˜­</h2>`;
            html += `<p style="font-size: 1.5em; color: #1E90FF;">æ‰€æŒ CRYSTAL: <span id="perm-crystal-display">${stats.crystal}</span></p><hr>`;
            html += `<p style="font-size: 1.1em; color: #ddd;">ã‚¯ãƒªã‚¹ã‚¿ãƒ«ã¯ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã«ã—ã‹ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚</p><hr>`;
            
            // æ°¸ç¶šã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
            html += `<div class="perm-panel"><h3>ğŸ’ æ°¸ç¶šã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰</h3>`;
            Object.keys(PERM_UPGRADES).forEach(key => {
                const item = PERM_UPGRADES[key];
                const currentVal = PERM_STATS[item.stat];
                
                let currentLevel = 0;
                if(item.stat === 'goldMultiplier') currentLevel = (currentVal - defaultPermStats.goldMultiplier) / item.step;
                else if(item.stat === 'baseMaxHp') currentLevel = (currentVal - defaultPermStats.baseMaxHp) / item.step;
                else if(item.stat === 'baseDmgBonus') currentLevel = (currentVal - defaultPermStats.baseDmgBonus) / item.step;
                
                const currentCost = Math.floor(item.costBase * Math.pow(item.costMulti, currentLevel)); 
                const isDisabled = stats.crystal < currentCost || currentLevel >= item.max;
                const buttonText = currentLevel >= item.max ? "MAX" : `å¼·åŒ– ${currentCost}C`;
                
                // GOLD_MULTIã®è¡¨ç¤ºã‚’ä¸¸ã‚ã‚‹
                const displayCurrentVal = item.stat === 'goldMultiplier' ? `${(currentVal * 100).toFixed(0)}%` : currentVal;
                const nextVal = item.stat === 'goldMultiplier' ? `${((currentVal + item.step) * 100).toFixed(0)}%` : `+${item.step}`;
                const detailText = `ç¾åœ¨ã®å€¤: ${displayCurrentVal} â†’ Next: ${nextVal}`;

                html += `<div class="shop-item">
                            <div>${item.name} <span style="font-size:0.8em; color:#bbb;">(Lv.${Math.floor(currentLevel)}/${item.max})</span></div>
                            <div class="details">${detailText}</div>
                            <button class="crystal-upgrade-button" onclick="buyPermUpgrade('${key}', ${currentCost})" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
                        </div>`;
            });
            html += `</div>`;

            // æ°¸ç¶šã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
            html += `<button id="reset-button" onclick="resetPermanentUpgrades()">
                        å…¨æ°¸ä¹…ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã¨CRYSTALæ®‹é«˜ã‚’ãƒªã‚»ãƒƒãƒˆ
                    </button>`;
            
            html += `<button onclick="restartGame()" style="padding: 15px 30px; font-size: 1.5em; background: #FF4136; color: white; border: none; border-radius: 5px; margin-top: 20px;">WAVE 1 ã‹ã‚‰ã‚„ã‚Šç›´ã™</button>`;
            
            permContainer.innerHTML = html;
            updateDisplay();
        }

        function buyPermUpgrade(itemId, cost) {
            if (stats.crystal < cost) return;
            
            const item = PERM_UPGRADES[itemId];
            
            PERM_STATS[item.stat] = PERM_STATS[item.stat] += item.step;
            stats.crystal -= cost;

            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
            save('permStats', PERM_STATS);
            save('crystal', stats.crystal);
            updatePermShopDisplay();
        }

        function updatePermShopDisplay() {
            document.getElementById('perm-upgrade-container').innerHTML = '';
            showPermanentUpgrade();
            updateDisplay();
        }

        function restartGame() {
            stats.gold = 0;
            // æ°¸ç¶šã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚’åæ˜ ã—ãŸåˆæœŸå€¤ã«ãƒªã‚»ãƒƒãƒˆ
            stats.maxHp = PERM_STATS.baseMaxHp;
            stats.currentHp = PERM_STATS.baseMaxHp;
            stats.bulletDmg = BASE_BULLET_DMG + PERM_STATS.baseDmgBonus;
            stats.fireRate = BASE_FIRE_RATE;
            stats.moveSpeed = BASE_MOVE_SPEED;
            
            Object.values(skillData).forEach(s => s.level = 0);
            
            document.getElementById('perm-upgrade-container').style.display = 'none';
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('start-screen').style.display = 'flex';
            gameStatus = 'init';
        }
        
        // æ°¸ç¶šã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ãƒªã‚»ãƒƒãƒˆ
        function resetPermanentUpgrades() {
            if (confirm("æœ¬å½“ã«å…¨ã¦ã®æ°¸ä¹…ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã¨CRYSTALæ®‹é«˜ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚")) {
                // localStorageã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸå€¤ã§ä¸Šæ›¸ãï¼ˆå‰Šé™¤ã¨åŒç¾©ï¼‰
                localStorage.removeItem('permStats');
                localStorage.removeItem('crystal');
                
                // ç¾åœ¨ã®ãƒ¡ãƒ¢ãƒªä¸Šã®statsã‚‚åˆæœŸåŒ–
                Object.assign(PERM_STATS, defaultPermStats);
                stats.crystal = 0;
                
                alert("æ°¸ä¹…ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã¨CRYSTALæ®‹é«˜ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚ã‚²ãƒ¼ãƒ ã‚’å†ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚");
                window.location.reload();
            }
        }


        // --- ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— ---

        function gameLoop() {
            if (gameStatus !== 'playing') return;
            gameFrame++; 
            ctx.textAlign = 'start';

            playerShoot(); 
            updateSkills(); 

            player.update();
            // ãƒœã‚¹ãŒå€’ã‚ŒãŸç›´å¾Œ(startNextWaveãŒå‘¼ã°ã‚ŒãŸç›´å¾Œ)ã¯enemy.update()ã‚’å‘¼ã°ãªã„
            if (gameStatus === 'playing') enemy.update();
            
            checkCollisions();

            // æç”»
            ctx.clearRect(0, 0, WIDTH, HEIGHT); 
            ctx.fillStyle = '#00001a';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            enemy.draw(); 
            items.forEach(item => item.draw());
            player.draw();
            playerBullets.forEach(bullet => bullet.draw());
            enemyBullets.forEach(bullet => bullet.draw());
            
            drawHUD();

            requestAnimationFrame(gameLoop);
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            const key = e.key.toLowerCase();
            
            if (gameStatus === 'playing') {
                if (key === skillData.HEAL.key) activateSkill('HEAL');
                else if (key === skillData.FULL_BURST.key) activateSkill('FULL_BURST');
                else if (key === skillData.BARRIER.key) activateSkill('BARRIER');
            }

            if (key === 'w' || key === 'a' || key === 's' || key === 'd' || key === 'shift' || key === 'z' || key === ' ' || key === 'x' || key.includes('arrow') || key === 'j' || key === 'k' || key === 'l') {
                e.preventDefault(); 
            }

        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // --- ãƒ‰ãƒ©ãƒƒã‚°/ã‚¿ãƒƒãƒæ“ä½œ ---
        function getCanvasMousePosition(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            const x = (clientX - rect.left) * (canvas.width / rect.width);
            const y = (clientY - rect.top) * (canvas.height / rect.height);
            return { x, y };
        }
        
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function handleDragStart(event) {
            if (gameStatus !== 'playing') return;
            const pos = getCanvasMousePosition(event);
            
            dragOffsetX = pos.x - player.getCenter().x;
            dragOffsetY = pos.y - player.getCenter().y;
            
            isDragging = true;
            keys['Shift'] = true; 
            event.preventDefault(); 
        }

        function handleDragMove(event) {
            if (!isDragging || gameStatus !== 'playing') return;
            const pos = getCanvasMousePosition(event);
            
            let newX = pos.x - dragOffsetX - player.width / 2;
            let newY = pos.y - dragOffsetY - player.height / 2;

            newX = Math.max(0, Math.min(newX, WIDTH - player.width));
            newY = Math.max(0, Math.min(newY, HEIGHT - player.height));
            
            player.x = newX;
            player.y = newY;
            
            event.preventDefault(); 
        }

        function handleDragEnd() {
            isDragging = false;
            keys['Shift'] = false; 
        }

        // PCå‘ã‘ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('mousedown', handleDragStart);
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);

        // ã‚¹ãƒãƒ›/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå‘ã‘ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('touchstart', handleDragStart);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', handleDragEnd);


    </script>
</body>
</html>
