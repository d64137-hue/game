<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Shmup_Game.html (è£½å“ç‰ˆ v6 - ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ— & Waveåˆ¶)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            background: #2a2a2a; 
            color: white; 
            text-align: center; 
            font-family: sans-serif; 
            margin: 0; 
            padding-top: 20px; 
            padding-bottom: 50px; 
            overflow-y: auto;
        }
        h1 {
            color: #76FF03; 
            margin-bottom: 20px;
        }
        #GameArea {
            max-width: 600px; 
            margin: 0 auto;
            padding: 20px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #1e1e1e;
        }
        #GameCanvas {
            background: #00001a;
            border: 2px solid #FFC300;
            display: block;
            margin: 20px auto;
            cursor: pointer; 
            touch-action: none; 
        }
        #ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 1.1em;
            color: #FFC300;
        }
        .ui-item {
            margin: 0 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 1.0em;
            background-color: #76FF03;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 15px;
        }
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            text-shadow: 2px 2px 5px black;
            z-index: 10;
            display: none; 
        }
        #final-score-display {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #FFC300;
        }
        #score-display {
            color: white;
        }
        #power-display {
            color: #FFC300;
        }
        #wave-display {
            color: #76FF03;
        }
    </style>
</head>
<body>
    <div id="GameArea">
        <h1>Shmup_Game.html (è£½å“ç‰ˆ v6)</h1>
        
        <div id="ui-panel">
            <div class="ui-item">WAVE: <span id="wave-display">1</span></div>
            <div class="ui-item">SCORE: <span id="score-display">0</span></div>
            <div class="ui-item">POWER: <span id="power-display">P0</span></div>
        </div>

        <canvas id="GameCanvas" width="500" height="650"></canvas>
        
        <div id="game-over-screen">
            <h2>GAME OVER</h2>
            <div id="final-score-display">æœ€çµ‚ã‚¹ã‚³ã‚¢: 0</div>
            <button onclick="retryGame()">ãƒªãƒˆãƒ©ã‚¤</button>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('GameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = canvas.width; 
        const HEIGHT = canvas.height; 

        // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹å¤‰æ•° ---
        let gameStatus = 'playing'; 
        let keys = {};
        let player = {};
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let items = []; // â˜…è¿½åŠ : ã‚¢ã‚¤ãƒ†ãƒ é…åˆ—

        let score = 0; // â˜…è¿½åŠ : ã‚¹ã‚³ã‚¢
        let powerLevel = 0; // â˜…è¿½åŠ : ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ãƒ¬ãƒ™ãƒ«
        let currentWave = 1; // â˜…è¿½åŠ : Wave
        let enemySpawnTimer = 0; // â˜…è¿½åŠ : æ•µã®å‡ºç¾ç®¡ç†
        let enemiesToSpawn = 0; // â˜…è¿½åŠ : ãã®Waveã§å‡ºç¾ã•ã›ã‚‹æ•µã®ç·æ•°
        let enemiesSpawned = 0; // â˜…è¿½åŠ : ã™ã§ã«å‡ºç¾ã•ã›ãŸæ•µã®æ•°

        const PLAYER_SPEED = 4;
        const PLAYER_SLOW_SPEED = 1.5;

        // --- ã‚¯ãƒ©ã‚¹å®šç¾© ---

        class Player {
            constructor() {
                this.width = 40; this.height = 40;
                this.x = WIDTH / 2 - this.width / 2; this.y = HEIGHT - 60;
                this.hitboxRadius = 2; 
                this.color = '#76FF03';
                this.fireRate = 10; // åŸºç¤é€£å°„é–“éš”ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼‰
                this.fireTimer = 0;
            }
            getCenter() { return { x: this.x + this.width / 2, y: this.y + this.height / 2 }; }
            update() {
                let speed = keys['Shift'] ? PLAYER_SLOW_SPEED : PLAYER_SPEED;
                
                if (keys['w'] || keys['W'] || keys['ArrowUp']) this.y -= speed;
                if (keys['s'] || keys['S'] || keys['ArrowDown']) this.y += speed;
                if (keys['a'] || keys['A'] || keys['ArrowLeft']) this.x -= speed;
                if (keys['d'] || keys['D'] || keys['ArrowRight']) this.x += speed;

                this.x = Math.max(0, Math.min(this.x, WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, HEIGHT - this.height));

                this.fireTimer++;
                // ğŸš€ ãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦é€£å°„é€Ÿåº¦ã‚’é«˜é€ŸåŒ–
                const actualFireRate = Math.max(3, this.fireRate - powerLevel * 2);
                if (this.fireTimer >= actualFireRate && (keys['x'] || keys['X'])) {
                    this.fire();
                    this.fireTimer = 0;
                }
            }
            fire() { // â˜…å¼·åŒ–: ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã«å¿œã˜ãŸå¼¾ã®ç™ºå°„
                const center = this.getCenter();
                const bulletSpeed = 10;
                const bulletDamage = 1 + powerLevel * 0.5;

                // ãƒ¬ãƒ™ãƒ«0 (P0): å˜ç™º
                bullets.push(new Bullet(center.x - 2, center.y, 0, bulletSpeed, bulletDamage));

                // ãƒ¬ãƒ™ãƒ«1ä»¥ä¸Š (P1): 2é€£å°„
                if (powerLevel >= 1) {
                    bullets.push(new Bullet(center.x - 8, center.y, 0, bulletSpeed, bulletDamage));
                    bullets.push(new Bullet(center.x + 4, center.y, 0, bulletSpeed, bulletDamage));
                }
                
                // ãƒ¬ãƒ™ãƒ«2ä»¥ä¸Š (P2): 3é€£å°„ï¼ˆåºƒç¯„å›²ï¼‰
                if (powerLevel >= 2) {
                    bullets.push(new Bullet(center.x - 12, center.y, -0.5, bulletSpeed, bulletDamage));
                    bullets.push(new Bullet(center.x, center.y, 0, bulletSpeed, bulletDamage));
                    bullets.push(new Bullet(center.x + 8, center.y, 0.5, bulletSpeed, bulletDamage));
                }
                
                // ãƒ¬ãƒ™ãƒ«3 (P3): 5é€£å°„ (ã•ã‚‰ã«åºƒç¯„å›²)
                if (powerLevel >= 3) {
                    bullets.push(new Bullet(center.x - 16, center.y, -1.0, bulletSpeed, bulletDamage));
                    bullets.push(new Bullet(center.x + 12, center.y, 1.0, bulletSpeed, bulletDamage));
                }
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                if (keys['Shift']) {
                    const center = this.getCenter();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, this.hitboxRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Bullet {
            constructor(x, y, dx, speed, damage) {
                this.x = x; this.y = y;
                this.width = 4; this.height = 10;
                this.dx = dx;
                this.speed = speed;
                this.damage = damage; // â˜…è¿½åŠ : ãƒ€ãƒ¡ãƒ¼ã‚¸å€¤
                this.color = 'white';
            }
            update() {
                this.y -= this.speed;
                this.x += this.dx;
                return this.y < 0; 
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        class Enemy { // â˜…å¼·åŒ–: ã‚¨ãƒªãƒ¼ãƒˆæ•µã¨HPãƒãƒ¼ã«å¯¾å¿œ
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.type = type; 
                
                if (type === 'elite') {
                    this.width = 30; this.height = 30;
                    this.health = 50 + currentWave * 15; // é«˜è€ä¹…
                    this.maxHealth = this.health;
                    this.speed = 0.8;
                    this.color = 'orange';
                    this.scoreValue = 500;
                    this.fireRate = 60; // æ”»æ’ƒé »åº¦é«˜ã‚
                } else { // 'normal'
                    this.width = 20; this.height = 20;
                    this.health = 10 + currentWave * 3;
                    this.maxHealth = this.health;
                    this.speed = 2 + currentWave * 0.1;
                    this.color = 'red';
                    this.scoreValue = 100;
                    this.fireRate = 120;
                }
                this.fireTimer = Math.random() * this.fireRate;
            }
            getCenter() { return { x: this.x + this.width / 2, y: this.y + this.height / 2 }; }
            update() {
                this.y += this.speed;
                
                this.fireTimer++;
                if (this.fireTimer >= this.fireRate) {
                    this.fire();
                    this.fireTimer = 0;
                }

                return this.y > HEIGHT || this.health <= 0;
            }
            fire() {
                const center = this.getCenter();
                const dx = player.getCenter().x - center.x;
                const dy = player.getCenter().y - center.y;
                const angle = Math.atan2(dy, dx);
                
                enemyBullets.push(new EnemyBullet(center.x, center.y, angle, 4));

                if (this.type === 'elite') {
                    // ã‚¨ãƒªãƒ¼ãƒˆæ•µã¯æ‹¡æ•£å¼¾ã‚’æ’ƒã¤
                    enemyBullets.push(new EnemyBullet(center.x, center.y, angle - 0.2, 4));
                    enemyBullets.push(new EnemyBullet(center.x, center.y, angle + 0.2, 4));
                }
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // HPãƒãƒ¼ã®æç”»
                if (this.health < this.maxHealth) {
                    const hpRatio = this.health / this.maxHealth;
                    const barWidth = this.width;
                    ctx.fillStyle = 'black';
                    ctx.fillRect(this.x, this.y - 8, barWidth, 4);
                    ctx.fillStyle = hpRatio > 0.5 ? 'lime' : 'yellow';
                    ctx.fillRect(this.x, this.y - 8, barWidth * hpRatio, 4);
                }
            }
            dropItem() { // â˜…è¿½åŠ : ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ­ãƒƒãƒ—
                if (Math.random() < 0.3) { 
                    items.push(new Item(this.getCenter().x, this.getCenter().y, 'P'));
                }
            }
        }

        class EnemyBullet {
            constructor(x, y, angle, speed) {
                this.x = x; this.y = y;
                this.radius = 4;
                this.speed = speed;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.color = 'red';
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                return this.x < -10 || this.x > WIDTH + 10 || this.y < -10 || this.y > HEIGHT + 10;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Item { // â˜…è¿½åŠ : ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒ©ã‚¹
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.type = type; 
                this.radius = 8;
                this.speed = 1.5;
                this.color = '#00FFFF'; // ã‚·ã‚¢ãƒ³
            }
            getCenter() { return { x: this.x, y: this.y }; }
            update() {
                this.y += this.speed;
                return this.y > HEIGHT;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold 10px sans-serif';
                ctx.fillText(this.type, this.x, this.y + 1);
            }
            applyEffect() {
                if (this.type === 'P') {
                    powerLevel = Math.min(3, powerLevel + 1); // æœ€å¤§P3
                    score += 500;
                    updateUI();
                }
            }
        }


        // --- ã‚²ãƒ¼ãƒ ç®¡ç†é–¢æ•° ---

        function initGame() {
            player = new Player();
            enemies = [];
            bullets = [];
            enemyBullets = [];
            items = [];
            score = 0;
            powerLevel = 0;
            currentWave = 1;
            gameStatus = 'playing';

            enemiesToSpawn = getWaveEnemyCount(currentWave);
            enemiesSpawned = 0;

            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('GameCanvas').style.opacity = '1';
            updateUI();
        }
        
        function getWaveEnemyCount(wave) {
            return 10 + wave * 5; 
        }

        function updateGame() {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            player.update();

            // æ•µã®å‡ºç¾
            handleEnemySpawn(); // â˜…Waveã‚·ã‚¹ãƒ†ãƒ ã«å¯¾å¿œ

            // æ•µã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã¨é™¤å»
            enemies = enemies.filter(enemy => {
                const removed = enemy.update();
                if (removed && enemy.health <= 0) { // æ’ƒç ´ã•ã‚ŒãŸæ•µã®ã¿ãƒ‰ãƒ­ãƒƒãƒ—åˆ¤å®š
                    enemy.dropItem();
                }
                return !removed && enemy.health > 0;
            });

            // å¼¾ã¨ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã¨é™¤å»
            bullets = bullets.filter(bullet => !bullet.update());
            enemyBullets = enemyBullets.filter(bullet => !bullet.update());
            items = items.filter(item => !item.update()); // â˜…ã‚¢ã‚¤ãƒ†ãƒ æ›´æ–°

            // è¡çªåˆ¤å®š
            handleCollisions();
            
            // Waveã‚¯ãƒªã‚¢åˆ¤å®š
            if (enemiesSpawned >= enemiesToSpawn && enemies.length === 0) {
                startNextWave();
            }
        }

        function handleEnemySpawn() { // â˜…Waveã‚·ã‚¹ãƒ†ãƒ ã«å¯¾å¿œ
            if (enemiesSpawned < enemiesToSpawn) {
                enemySpawnTimer++;
                const spawnInterval = Math.max(30, 90 - currentWave * 5); 

                if (enemySpawnTimer >= spawnInterval) {
                    // WaveãŒé€²ã‚€ã»ã©ã‚¨ãƒªãƒ¼ãƒˆæ•µã®å‡ºç¾ç‡ãŒä¸ŠãŒã‚‹
                    let eliteChance = 0.05 + currentWave * 0.02; 
                    let enemyType = (Math.random() < eliteChance) ? 'elite' : 'normal';
                    let x = Math.random() * (WIDTH - 50) + 25;
                    enemies.push(new Enemy(x, -50, enemyType));
                    enemiesSpawned++;
                    enemySpawnTimer = 0;
                }
            }
        }

        function handleCollisions() {
            const playerCenter = player.getCenter();
            // Shiftã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã„ã‚‹/ã‚¿ãƒƒãƒãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ç²¾å¯†åˆ¤å®šã€ãã‚Œä»¥å¤–ã¯åºƒã‚ã®åˆ¤å®š
            const playerHitboxRadius = keys['Shift'] ? player.hitboxRadius : player.width / 2 * 0.8;

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ã¨æ•µ (ãƒ€ãƒ¡ãƒ¼ã‚¸ã¨ã‚¹ã‚³ã‚¢å‡¦ç†ã‚’å«ã‚€)
            bullets = bullets.filter(bullet => {
                let hit = false;
                enemies.forEach(enemy => {
                    if (enemy.health > 0) {
                        const enemyCenter = enemy.getCenter();
                        const dist = Math.sqrt(Math.pow(bullet.x - enemyCenter.x, 2) + Math.pow(bullet.y - enemyCenter.y, 2));
                        
                        if (dist < enemy.width / 2 + 5) {
                            enemy.health -= bullet.damage;
                            hit = true;
                            if (enemy.health <= 0) {
                                score += enemy.scoreValue; // â˜…ã‚¹ã‚³ã‚¢åŠ ç®—
                            }
                            updateUI();
                        }
                    }
                });
                return !hit;
            });

            // æ•µå¼¾ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            enemyBullets = enemyBullets.filter(bullet => {
                const dist = Math.sqrt(Math.pow(bullet.x - playerCenter.x, 2) + Math.pow(bullet.y - playerCenter.y, 2));
                if (dist < playerHitboxRadius + bullet.radius) {
                    gameOver();
                    return false; 
                }
                return true;
            });

            // ã‚¢ã‚¤ãƒ†ãƒ ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (æ¥è§¦ã§å–å¾—)
            items = items.filter(item => {
                const itemCenter = item.getCenter();
                const dist = Math.sqrt(Math.pow(itemCenter.x - playerCenter.x, 2) + Math.pow(itemCenter.y - playerCenter.y, 2));
                if (dist < item.radius + player.width / 2 * 0.8) {
                    item.applyEffect();
                    return false; // ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
                }
                return true;
            });
        }
        
        function startNextWave() { // â˜…Waveé€²è¡Œå‡¦ç†
            currentWave++;
            enemiesSpawned = 0;
            enemiesToSpawn = getWaveEnemyCount(currentWave);
            
            // ä¾‹: Waveé–‹å§‹æ™‚ã®é€šçŸ¥ãªã©ã‚’å…¥ã‚Œã‚‹ã¨æ¼”å‡ºãŒè‰¯ããªã‚‹
            // console.log(`WAVE ${currentWave} START!`);
            
            updateUI();
        }

        function gameOver() {
            gameStatus = 'gameover';
            document.getElementById('final-score-display').textContent = `æœ€çµ‚ã‚¹ã‚³ã‚¢: ${score}`;
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã©ã§å¼·èª¿ã—ã¦ã‚‚è‰¯ã„
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('GameCanvas').style.opacity = '0.5';
        }

        function retryGame() {
            initGame();
            gameLoop();
        }

        // --- æç”»é–¢æ•° ---

        function draw() {
            ctx.fillStyle = '#00001a'; ctx.fillRect(0, 0, WIDTH, HEIGHT);

            items.forEach(item => item.draw()); // â˜…ã‚¢ã‚¤ãƒ†ãƒ æç”»
            enemies.forEach(enemy => enemy.draw());
            enemyBullets.forEach(bullet => bullet.draw());
            bullets.forEach(bullet => bullet.draw());
            player.draw();
        }

        function updateUI() { // â˜…UIæ›´æ–°é–¢æ•°
            document.getElementById('score-display').textContent = score;
            document.getElementById('power-display').textContent = `P${powerLevel}`;
            document.getElementById('wave-display').textContent = currentWave;
        }

        // --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ---

        function gameLoop() {
            if (gameStatus === 'playing') {
                updateGame();
                draw();
            }

            requestAnimationFrame(gameLoop);
        }

        // --- æ“ä½œã‚¤ãƒ™ãƒ³ãƒˆ ---

        document.addEventListener('keydown', (e) => {
            if (['w', 'a', 's', 'd', 'x', 'W', 'A', 'S', 'D', 'X', 'Shift', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                keys[e.key] = true;
                e.preventDefault(); 
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // --- ã‚¿ãƒƒãƒ/ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œ (â˜…è‡ªå‹•æ”»æ’ƒæ©Ÿèƒ½ã‚’çµ„ã¿è¾¼ã¿) ---
        let isDragging = false;
        let dragOffsetX, dragOffsetY;

        function getCanvasMousePosition(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleDragStart(event) {
            if (gameStatus !== 'playing') return;
            const pos = getCanvasMousePosition(event);
            
            const playerCenter = player.getCenter();
            dragOffsetX = pos.x - playerCenter.x;
            dragOffsetY = pos.y - playerCenter.y;
            
            isDragging = true;
            keys['Shift'] = true; // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯è‡ªå‹•çš„ã«ä½é€Ÿç§»å‹•ã‚’ON
            keys['x'] = true;     // â˜…è¿½åŠ : ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯è‡ªå‹•çš„ã«æ”»æ’ƒã‚’ON
            event.preventDefault(); 
        }

        function handleDragMove(event) {
            if (!isDragging || gameStatus !== 'playing') return;
            const pos = getCanvasMousePosition(event);
            
            let newX = pos.x - dragOffsetX - player.width / 2;
            let newY = pos.y - dragOffsetY - player.height / 2;

            newX = Math.max(0, Math.min(newX, WIDTH - player.width));
            newY = Math.max(0, Math.min(newY, HEIGHT - player.height));
            
            player.x = newX;
            player.y = newY;
            
            event.preventDefault(); 
        }

        function handleDragEnd() {
            isDragging = false;
            keys['Shift'] = false; // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ã§ä½é€Ÿç§»å‹•ã‚’OFF
            keys['x'] = false;     // â˜…è¿½åŠ : ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ã§è‡ªå‹•æ”»æ’ƒã‚’OFF
        }

        // PCå‘ã‘ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('mousedown', handleDragStart);
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);

        // ã‚¹ãƒãƒ›/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå‘ã‘ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
        canvas.addEventListener('touchstart', handleDragStart);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', handleDragEnd);

        // --- åˆæœŸåŒ– ---
        initGame();
        gameLoop();
    </script>
</body>
</html>
