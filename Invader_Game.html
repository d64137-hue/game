<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>HTMLã‚¤ãƒ³ãƒ™ãƒ¼ãƒ€ãƒ¼ã‚²ãƒ¼ãƒ ï¼ˆHMGé€£å°„é€Ÿåº¦èª¿æ•´ç‰ˆï¼‰</title>
    <style>
        /* CSS: ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }
        canvas {
            border: 2px solid #fff; /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ç™½ã„æ ç·š */
            background-color: #000;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="600" height="400"></canvas>

    <script>
        // 1. ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®åˆæœŸè¨­å®š
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 2. ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®šç¾©
        const player = {
            x: canvas.width / 2 - 20,
            y: canvas.height - 40,
            width: 40,
            height: 10,
            speed: 5,
            color: 'lime',
            isAlive: true
        };

        const bullets = [];     
        let enemies = [];       
        const enemyBullets = [];
        let score = 0;
        let lives = 3;          
        let gameStatus = 'playing'; 
        
        let stage = 1;              
        let baseEnemyHP = 1;        
        
        const enemyBulletBaseWidth = 2;
        const enemyBulletBaseHeight = 8;
        
        // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—é–¢é€£ã®å¤‰æ•°
        let baseBulletDamage = 1;       
        let permanentDamageBonus = 0;   
        let temporaryDamageMultiplier = 1; 
        let heavyMachineGunEndTime = 0; 
        let notification = {
            message: '',
            color: '',
            outline: '',
            startTime: 0,
            duration: 2000 
        };
        let lastPlayerShotTime = 0;
        
        const playerShotCooldown = 400; // é€šå¸¸æ™‚ã®é€£å°„ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ (0.4ç§’)
        
        // --- ğŸ”´ HMGã®é€£å°„ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’100msã«è¨­å®š ---
        const hmgShotCooldown = 100;    // HMGç™ºå‹•æ™‚ã®é€£å°„ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ (0.1ç§’)
        // ---------------------------------------------
        
        // ã‚¹ã‚³ã‚¢é€£å‹•HPå¢—åŠ ç”¨å¤‰æ•°
        let currentScoreHPBonus = 0;        
        let next1000ScoreThreshold = 1000;  
        let next5000ScoreThreshold = 5000;  
        let next10000ScoreThreshold = 10000; 

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’ç®¡ç†
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // ----------------------------------------------
        // 3. ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆé–¢æ•°
        // ----------------------------------------------

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã®ç”Ÿæˆ (å¤‰æ›´ãªã—)
        function createBullet() {
            if (bullets.length < 3) {
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    width: 4,
                    height: 10,
                    speed: 7,
                    color: 'white',
                    damage: (baseBulletDamage + permanentDamageBonus) * temporaryDamageMultiplier
                });
            }
        }
        
        // æ•µã®å¼¾ã®ç”Ÿæˆ (å¤‰æ›´ãªã—)
        function createEnemyBullet(enemy) {
            const bulletSize = enemyBulletBaseWidth; 
            const bulletHeight = enemyBulletBaseHeight;

            enemyBullets.push({
                x: enemy.x + enemy.width / 2 - bulletSize / 2,
                y: enemy.y + enemy.height,
                width: bulletSize,
                height: bulletHeight,
                speed: 3 + stage * 0.2, 
                color: 'red'
            });
        }
        
        // æ•µã®åˆæœŸé…ç½® (å¤‰æ›´ãªã—)
        function initializeEnemies() {
            enemies = []; 
            const currentEnemyHP = baseEnemyHP + (stage - 1) + currentScoreHPBonus; 
            
            const rows = 3;
            const cols = 8;
            const enemyWidth = 30;
            const enemyHeight = 20;
            const padding = 10;
            const offsetX = 50;
            const offsetY = 30;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    enemies.push({
                        x: c * (enemyWidth + padding) + offsetX,
                        y: r * (enemyHeight + padding) + offsetY,
                        width: enemyWidth,
                        height: enemyHeight,
                        color: ['red', 'orange', 'yellow'][r % 3],
                        isAlive: true,
                        hp: currentEnemyHP
                    });
                }
            }
        }

        // ----------------------------------------------
        // 4. æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ (Update)
        // ----------------------------------------------
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ›´æ–° (é€£å°„ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’ä¿®æ­£)
        function updatePlayer() {
            if (!player.isAlive) return;
            
            if (keys['ArrowLeft'] || keys['a']) {
                player.x -= player.speed;
            }
            if (keys['ArrowRight'] || keys['d']) {
                player.x += player.speed;
            }
            
            const currentTime = Date.now();
            let cooldown = playerShotCooldown; 

            // HMGç™ºå‹•æ™‚ã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’100msã«è¨­å®š
            if (temporaryDamageMultiplier === 2) {
                cooldown = hmgShotCooldown; 
            }
            
            if (keys[' '] && currentTime - lastPlayerShotTime > cooldown) {
                createBullet();
                lastPlayerShotTime = currentTime;
            }
            
            player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));
        }

        // å¼¾ã®æ›´æ–° (å¤‰æ›´ãªã—)
        function updateBullets() {
            for (let i = 0; i < bullets.length; i++) {
                bullets[i].y -= bullets[i].speed;
            }
            for (let i = bullets.length - 1; i >= 0; i--) {
                if (bullets[i].y < 0) {
                    bullets.splice(i, 1);
                }
            }

            for (let i = 0; i < enemyBullets.length; i++) {
                enemyBullets[i].y += enemyBullets[i].speed;
            }
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                if (enemyBullets[i].y > canvas.height) {
                    enemyBullets.splice(i, 1);
                }
            }
        }

        // æ•µã®æ›´æ–°ï¼ˆå·¦å³ç§»å‹•ã€ä¸‹é™ã€æ”»æ’ƒï¼‰ (å¤‰æ›´ãªã—)
        let enemyDirection = 1; 
        let enemySpeed = 0.5;
        const dropStep = 5;
        let lastShotTime = 0;
        const shotInterval = 1000; 

        function updateEnemies() {
            let hitEdge = false;
            const aliveEnemies = enemies.filter(e => e.isAlive);

            if (aliveEnemies.length === 0) return;

            aliveEnemies.forEach(enemy => {
                enemy.x += enemyDirection * enemySpeed;
            });

            aliveEnemies.forEach(enemy => {
                if (enemy.x + enemy.width > canvas.width || enemy.x < 0) {
                    hitEdge = true;
                }
            });

            if (hitEdge) {
                enemyDirection *= -1;
                aliveEnemies.forEach(enemy => {
                    enemy.y += dropStep;
                    if (enemy.y + enemy.height >= player.y) {
                         gameStatus = 'gameover';
                    }
                });
            }
            
            const currentTime = performance.now();
            const adjustedShotInterval = shotInterval - stage * 50; 
            if (currentTime - lastShotTime > adjustedShotInterval) {
                const shooter = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
                createEnemyBullet(shooter);
                lastShotTime = currentTime + Math.random() * 1000 - 500;
            }
        }

        // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—çŠ¶æ…‹ã®æ›´æ–° (å¤‰æ›´ãªã—)
        function updatePowerUps() {
            const currentTime = Date.now();
            
            if (currentTime < heavyMachineGunEndTime) {
                temporaryDamageMultiplier = 2;
            } else {
                temporaryDamageMultiplier = 1;
                heavyMachineGunEndTime = 0;
            }

            if (currentTime > notification.startTime + notification.duration) {
                notification.message = '';
            }
        }
        
        // ã‚¹ã‚³ã‚¢é€£å‹•HPå¢—åŠ ã®ãƒã‚§ãƒƒã‚¯ (å¤‰æ›´ãªã—)
        function checkScoreHPIncrease() {
            // 1000ç‚¹ã”ã¨ (HP+1)
            while (score >= next1000ScoreThreshold) {
                currentScoreHPBonus += 1;
                next1000ScoreThreshold += 1000;
            }

            // 5000ç‚¹ã”ã¨ (HP+3)
            while (score >= next5000ScoreThreshold) {
                currentScoreHPBonus += 3;
                next5000ScoreThreshold += 5000;
            }

            // 10000ç‚¹ã”ã¨ (HP+5)
            while (score >= next10000ScoreThreshold) {
                currentScoreHPBonus += 5;
                next10000ScoreThreshold += 10000;
            }
        }

        // ----------------------------------------------
        // 5. è¡çªåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
        // ----------------------------------------------
        function checkCollision(objA, objB) {
            return objA.x < objB.x + objB.width &&
                   objA.x + objA.width > objB.x &&
                   objA.y < objB.y + objB.height &&
                   objA.y + objA.height > objB.y;
        }

        function handleCollisions() {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ vs æ•µ
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    if (enemy.isAlive && checkCollision(bullet, enemy)) {
                        const originalScore = score; 
                        enemy.hp -= bullet.damage;
                        bullets.splice(i, 1); 
                        
                        if (enemy.hp <= 0) {
                            enemy.isAlive = false;
                            score += 10 * stage; 
                            
                            if (score > originalScore) {
                                checkScoreHPIncrease();
                            }

                            // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ç¢ºç‡ã®æŠ½é¸
                            const rand = Math.random();
                            
                            // (1) ãƒ˜ãƒ“ãƒ¼ãƒã‚·ãƒ³ã‚¬ãƒ³ (3%ã®ç¢ºç‡)
                            if (rand < 0.03) { 
                                heavyMachineGunEndTime = Date.now() + 15000; 
                                notification.message = 'HEAVY MACHINEGUN';
                                notification.color = 'gray';
                                notification.outline = 'red';
                                notification.startTime = Date.now();
                            } 
                            // (2) æ°¸ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¢ãƒƒãƒ— (2%ã®ç¢ºç‡)
                            else if (rand >= 0.03 && rand < 0.05) { 
                                permanentDamageBonus += 2;
                                notification.message = 'MORE POWER';
                                notification.color = 'orange';
                                notification.outline = 'none'; 
                                notification.startTime = Date.now();
                            }
                        }
                        break; 
                    }
                }
            }
            
            // æ•µã®å¼¾ vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ (å¤‰æ›´ãªã—)
            if (player.isAlive) {
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const eBullet = enemyBullets[i];

                    if (checkCollision(eBullet, player)) {
                        enemyBullets.splice(i, 1); 
                        lives -= 1; 
                        
                        if (lives <= 0) {
                            player.isAlive = false;
                            gameStatus = 'gameover';
                        } else {
                            enemyBullets.length = 0;
                            player.x = canvas.width / 2 - 20;
                        }
                        break;
                    }
                }
            }

            // ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢åˆ¤å®š (å¤‰æ›´ãªã—)
            if (enemies.filter(e => e.isAlive).length === 0) {
                stage += 1;
                enemySpeed += 0.1; 
                initializeEnemies();
                enemyBullets.length = 0; 
            }
        }

        // ----------------------------------------------
        // 6. æç”»ãƒ­ã‚¸ãƒƒã‚¯ (Draw)
        // ----------------------------------------------

        // æ•µã®æç”»ã¨HPè¡¨ç¤º (å¤‰æ›´ãªã—)
        function drawEnemies() {
            enemies.forEach(enemy => {
                if (enemy.isAlive) {
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(enemy.hp, enemy.x + enemy.width / 2, enemy.y + enemy.height + 10);
                }
            });
        }

        // HUD (Score/Lives/Stage/æ°¸ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ãƒœãƒ¼ãƒŠã‚¹) ã®æç”» (å¤‰æ›´ãªã—)
        function drawHUD() {
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('SCORE: ' + score, 10, 25);
            ctx.fillText('LIVES: ' + lives, canvas.width - 80, 25);
            
            ctx.textAlign = 'center';
            ctx.fillText('STAGE ' + stage, canvas.width / 2, 25);

            if (permanentDamageBonus > 0) {
                 ctx.fillStyle = 'orange';
                 ctx.textAlign = 'left';
                 ctx.fillText('DMG+' + permanentDamageBonus, 10, 45);
            }
            
            // ã‚¹ã‚³ã‚¢ã«ã‚ˆã‚‹HPãƒœãƒ¼ãƒŠã‚¹ã®è¡¨ç¤º
            if (currentScoreHPBonus > 0) {
                ctx.fillStyle = 'red'; 
                ctx.textAlign = 'right';
                ctx.fillText('Enemy HP: +' + currentScoreHPBonus, canvas.width - 10, 45);
            }
        }

        // ãƒ˜ãƒ“ãƒ¼ãƒã‚·ãƒ³ã‚¬ãƒ³æ®‹ã‚Šæ™‚é–“ã®ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¡¨ç¤º (å¤‰æ›´ãªã—)
        function drawHMGCountdown() {
            if (heavyMachineGunEndTime > 0) {
                const remainingTime = Math.ceil((heavyMachineGunEndTime - Date.now()) / 1000);
                if (remainingTime > 0) {
                    ctx.fillStyle = 'red';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('HMG: ' + remainingTime + 's', canvas.width / 2, 45);
                }
            }
        }

        // ç”»é¢ä¸­å¤®ã®ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—é€šçŸ¥è¡¨ç¤º (å¤‰æ›´ãªã—)
        function drawNotification() {
            if (notification.message !== '') {
                const elapsed = Date.now() - notification.startTime;
                const isVisible = Math.floor(elapsed / 250) % 2 === 0;

                if (isVisible) {
                    ctx.font = '40px Arial';
                    ctx.textAlign = 'center';

                    if (notification.outline === 'red') {
                        ctx.strokeStyle = notification.outline;
                        ctx.lineWidth = 4;
                        ctx.strokeText(notification.message, canvas.width / 2, canvas.height / 2);
                    }
                    
                    ctx.fillStyle = notification.color;
                    ctx.fillText(notification.message, canvas.width / 2, canvas.height / 2);
                }
            }
        }
        
        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã®æç”» (å¤‰æ›´ãªã—)
        function drawGameOver() {
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
            ctx.font = '24px Arial';
            ctx.fillText('Final Score: ' + score, canvas.width / 2, canvas.height / 2 + 50);
            ctx.fillText('Press F5 to Restart', canvas.width / 2, canvas.height / 2 + 90);
        }

        function draw() {
            // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameStatus === 'playing') {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æç”»
                if (player.isAlive) {
                    ctx.fillStyle = player.color;
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }
                
                // å¼¾ã®æç”»
                ctx.fillStyle = 'white';
                bullets.forEach(bullet => {
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });
                ctx.fillStyle = 'red';
                enemyBullets.forEach(bullet => {
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });

                drawEnemies();
                drawHUD();
                drawHMGCountdown();
                drawNotification();
            } else if (gameStatus === 'gameover') {
                drawGameOver();
            }
        }

        // ----------------------------------------------
        // 7. ãƒ¡ã‚¤ãƒ³ã®ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        // ----------------------------------------------
        function gameLoop() {
            if (gameStatus === 'playing') {
                updatePowerUps(); 

                updatePlayer();
                updateBullets();
                updateEnemies();
                handleCollisions();
            }

            draw();
            requestAnimationFrame(gameLoop);
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹ï¼
        initializeEnemies(); 
        gameLoop();
    </script>
</body>
</html>
